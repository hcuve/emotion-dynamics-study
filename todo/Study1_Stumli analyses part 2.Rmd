---
title: "Non Parametric Time Clustering of Face Dynamics"
author: "Helio"
date: "09/04/2021"
output: html_document
---


todo = improve readability, clean, etc

data is = FaceDynamicMorph_Simulationstudy.RData

```{r}
p<- list()
sf = 1 # constant for easily changing text size

p$graphstyle <-  theme(#base plot theme
  # axis
  axis.line.y = element_line(),
  axis.line.x = element_line(),
  axis.text.x = element_text(size = 15+(sf+.5), family = "sans", colour = "black", hjust = .8), #angle = 45,
  axis.text.y = element_text(size = 15+(sf+.5), family = "sans", colour = "black"),
  #axis.ticks = element_blank(),
  #axis.text.y = element_text(size= 18, family = "Arial Narrow", colour="black"),
  axis.title.y=element_text(size = 16*(sf+.7), margin=margin(0,5,0,0)),
  axis.title.x=element_text(size = 16*(sf+.7), margin=margin(0,5,0,0)),
  
  # strips
  strip.background = element_blank(),
  strip.text.x = element_text(size = 12*(sf+.5),  colour = "black"),
  strip.text.y = element_text(size = 12*(sf+.5),  colour = "black"),
  
  # panel
  # panel.background = element_rect(colour = NA),
  # plot.background = element_rect(colour = NA),
  # panel.border = element_rect(colour = NA),
  # panel.border = element_blank(),
  # panel.grid.major = element_blank(),
  # panel.grid.minor = element_blank(),
  # panel.background = element_blank(),
  
  # legend
  # legend.title = element_text(size = 10*(sf+.3)),
  legend.position = "top",
  legend.direction = "horizontal",
  #legend.key.size = unit(.5, "cm"),
  #legend.text = element_text(size = 10*sf),
  legend.title=element_blank(),
  #legend.text = element_blank(),
  legend.key = element_rect(colour = "transparent", fill="transparent"),
  # text
  text=element_text(size = 16*(sf+.4), family = "sans"))
 

p$graphstyle1 <-  theme(#base plot theme
  axis.line.y = element_blank(),
  axis.line.x = element_blank(),
  strip.text.x = element_text(size = 11*(sf+.5),  colour = "black"),
  strip.text.y = element_text(size = 11*(sf+.5),  colour = "black"),
  panel.border = element_blank(),
  panel.grid.major = element_blank(),
  panel.grid.minor = element_blank(),
  panel.background = element_blank(),
  #panel.background = element_rect(fill="transparent"),
  #panel.border = element_rect(fill="transparent"),
   # legend
  #legend.position = "top", 
  #legend.direction = "horizontal",
  #legend.key.size = unit(.5, "cm"),
  #legend.text = element_text(size = 10*sf+.3),
  legend.title = element_text(size = 10*(sf+.3)),
  #legend.key.size = unit(.5, "cm"),
  #legend.text = element_text(size = 10*sf),
  #legend.title=element_blank(),
  #legend.text = element_blank(),
  text=element_text(size = 14, family = "sans"),
  axis.text.x = element_text(size = 14, family = "sans", colour = "black",),
  axis.text.y = element_text(size = 14, family = "sans", colour = "black"),
  #axis.ticks = element_blank(),
  # strip shades (reco rectagles)
  strip.background = element_blank(),
  #axis.text.y = element_text(size= 18, family = "Arial Narrow", colour="black"),
  axis.title.y=element_text(size = 14*(sf+.5), margin=margin(0,5,0,0)),
  axis.title.x=element_text(size = 14*(sf+.5), margin=margin(0,5,0,0)),
  legend.key = element_rect(colour = "transparent", fill="transparent"))



```



okat test specific time clusters for ace average motion

```{r}
db_of7_new%>%
  ggplot(aes(timestamp, face_action_AVG2, colour = morph))+
  # geom_smooth()
  geom_line(aes(group = video), alpha = .2)+
  stat_summary(geom = 'line', size = 2)+
  facet_grid(Dataset~Emotion)

```


```{r}
library(itsadug)
library(tidyverse)
db_of5_new$timestamp
db_of6_new<-  db_of5_new%>%
  group_by(filename)%>%
  mutate(timebin = timeBins(timestamp, binsize = .15, pos = 0))

max(db_of6_new$timebin)


# install.packages("trinker")
# library(trink)

# aggregate by timebin

db_of7_new <- db_of6_new%>%
  group_by(filename, timebin, morph, Emotion, Dataset, video, face_unique)%>%
  summarise_if(is.numeric, mean, na.rm = TRUE)

# plot by timebin

db_of7_new%>%
  ggplot(aes(timebin, face_action_AVG, colour = morph))+
  stat_summary(geom = "line", size = 2)+
  geom_line(aes(group = video), alpha = .2)+
  facet_grid(~Dataset)+
  theme_minimal()


```



```{r}
db_of7_new$VideoType_contrast<- if_else(db_of7_new$morph == "Morph", -.5, +.5)


# create a vector with the timebins
timebinout_avg<- unique(db_of7_new$timebin)

# make sure face is a factor
db_of7_new$face_unique<- as.factor(db_of7_new$face_unique)
#findout how mny timebins do we have
db_of7_new%>%
  group_by(filename)%>%
  summarise(n = n()) #== 40

# create an empty dataframe that will hold the information from each test
test.data_avgface<- data.frame(timebins= rep(NA, 40), Estimate= rep(NA, 40), t=rep(NA, 40), p=rep(NA, 40), cov= as.character(rep(NA,40)) )

# test.data$timebinout<- as.vector(timebinout) # add the curerent timebins to that vector

# empty list of test results
testresults_avg<- list()
# lmer


i = 15 # currently we have 15 time bins
# the loop below does
# 1 - goes from element i ina  list of eleements 1 to the last time bind_cols
# 2- runs a lmer model regresing face distance to morph vs original, while controling for intercepts of dataset and intercept of unique faces
#3 - stores the result of the model
#4- store informatio on the bin tested, the coeficients, p values and t tests
# morph variance is almost zerp
# dtaset is highly correleted, so ignore

# i = 2

i=2

table(db_of7_new$VideoType_contrast)
unique(db_of7_new$face_unique)
test.data_avgface$cov<- as.character(test.data_avgface$cov)
View(db_of7_new)

for (i in 1:length(timebinout_avg)) {
  testresults_avg<- lmer(log1p(face_action_AVG2+.1) ~ VideoType_contrast + (1 |face_unique) ,
                           # (1| Dataset),
                         data = db_of7_new[db_of7_new$timebin == timebinout_avg[i],])
  
   summarytest_avg<- summary(testresults_avg)
   
   test.data_avgface[i,1]<-timebinout_avg[i]
  test.data_avgface[i,2]<- summarytest_avg[["coefficients"]][2,1]
   test.data_avgface[i,3]<-summarytest_avg[["coefficients"]][2,4]
   test.data_avgface[i,4]<-summarytest_avg[["coefficients"]][2,5]
   test.data[i,5]<- as.character(ifelse(length(summarytest_avg$optinfo$conv$lme4$message) == 0,'pass',
                             summarytest_avg$optinfo$conv$lme4$message))
   
   print(i)
}

View(   test.data_avgface)

# test.data_avgface_96<- data.frame(timebins= rep(NA, 96), Estimate= rep(NA, 96), t=rep(NA, 96), p=rep(NA, 96), cov= as.character(rep(NA,96)) )

# test.data$timebinout<- as.vector(timebinout) # add the curerent timebins to that vector

# empty list of test results
testresults_avg_96<- list()

 unique(db_of7_new$VideoType_contrast) # morph == -.5, original .5
# timebinout_avg96<- unique(db_of7_new $timestamp)
# for (i in 1:length(timebinout_avg)) {
#   testresults_avg<- lmer(log1p(face_action_AVG +.1) ~ morph + (1 |face_unique) + (1| Dataset),
#                       data = db_of7_new[db_of7_new$timestamp == timebinout_avg[i],])
# 
#   # testresults<- lmer(log1p(D1+.1) ~ morph + (1|face_unique),
#   #                     data = db_of8 [db_of8$timebin == timebinout[i] & db_of8$Dataset !="JEFFE",])
#    summarytest_avg<- summary(testresults_avg)
#    
#    test.data_avgface[i,1]<-timebinout_avg[i]
#   test.data_avgface[i,2]<- summarytest_avg[["coefficients"]][2,1]
#    test.data_avgface[i,3]<-summarytest_avg[["coefficients"]][2,4]
#    test.data_avgface[i,4]<-summarytest_avg[["coefficients"]][2,5]
#    # test.data[i,5]<- testresults@optinfo$val
#    print(i)
#    }

# now sum adjancet timebins
# create a flag for significance
# test.data_avgface$cluster<- if_else(test.data_avgface$p< .05, TRUE, FALSE)
test.data_avgface<- test.data_avgface%>%
  mutate(cluster_log = if_else(test.data_avgface$p< .05, TRUE, FALSE))%>%
  mutate(Direction = if_else(t > 0 & cluster_log == TRUE, "Positive", 
                             if_else(t < 0 & cluster_log == TRUE, "Negative", NULL)))%>% # flag direction that is
        # group_by(sim)%>%
        mutate(idx = !is.na(Direction))%>%
        mutate(cluster_counter  = as.numeric(replace(Direction, idx, rleid(rleid(Direction)[idx]))))%>%
      # create a cluster t sum by adjacency, remeber the up there we grouped 
      # cluster counter shuffle makes sure ajancent significant bisn are griuped together
      # direction - do we need thisDirection, cluster_shuffle_log 
      group_by(cluster_counter)%>%
      mutate(t_sum_dir = sum(t))%>%
      # ungroup()%>%
      mutate(t_sum_dir = if_else(cluster_log == TRUE, t_sum_dir, NULL))%>% #summ timebins into clusters statistics
        # create max cluster lavels, store the direction value of the cluster and the label of the direction
      # suppressWarnings
        # group_by(sim)%>%
      mutate(MaxCLust_label = if_else(abs(t_sum_dir) == max(abs(t_sum_dir), na.rm = TRUE),
                                      cluster_counter, NULL ))%>%
      # suppressWarnings
      mutate(MaxCLust_value = if_else(abs(t_sum_dir) == max(abs(t_sum_dir), na.rm = TRUE), 
                                      t_sum_dir, NULL ))%>%
      # suppressWarnings
      mutate(MaxCLust_direction = if_else(MaxCLust_value > 0, "Positive", "Negative"))
View(test.data_avgface)
# negative estmate = morph has less actiation
        
library(data.table)
# create a counter for helpting with cluster by adjancecy

# regular corrections
test.data_avgface<- test.data_avgface%>%
  mutate(p_bonf = p.adjust(p, method = 'holm'))%>%
  mutate(p_holm = p.adjust(p, method = "bonf"))





timebin_shuff<- unique(db_of7_new$timebin)

 # create a random arrangment of labels for oroginal and morpj
 
 
  testtemp%>%
    group_by(morph)%>%
    summarise(n= n())
  

 library(permute)

nsim = 1:100 #no. of simullation
nbins  =1:40 # numbr of bins. aways check

#create an empty dataframe to store results of the simulation
# remeber to always define it before simulation

simulated_clusters<- data.frame(timebins= rep(NA, max(nsim)*max(nbins)), Estimate= rep(NA, max(nsim)*max(nbins)), t=rep(NA, max(nsim)*max(nbins)), p=rep(NA, max(nsim)*max(nbins)), cov= as.character(rep(NA,max(nsim)*max(nbins))), sim = rep(NA, max(nsim)*max(nbins)) )
View(simulated_clusters)


timebin_random<- unique(db_of7_new$timebin)




# create random labels

table(is.na(db_of7_new$morph1))
install.packages("permute")
install.packages('foreach') 
library(permute)
library(foreach)
i = 1 # remember to always rezero it
# b = 34

seed = 444

 simulated_clusters$cov<- as.character( simulated_clusters$cov) # remeber to run

 i = 1
 # b = 1
 # s = 1
 
 unique(db_of7_new$VideoType_contrast) # morph == -.5, original .5
 
for (b in 1:length(nbins)) {
  for (s in 1:length(nsim)) {
    # tryCatch({
    #shuffle the predictor
    message(sprintf("$$$$$RUNING simulation %i & bin %i", nsim[s], nbins[b]))
    db_of7_new$VideoType_contrast_sample<- sample((rep(c(-.5, .5), each = 3840)), replace = FALSE) 
    # remeber to use sample withouth replacement to make sure the quantities remain the same in each level of the predictor

        #run the model on the current time bin and simulation sumber
        lmer_bin_random  <- lmer(log1p(face_action_AVG2+.1) ~ VideoType_contrast_sample + 
                                   (1 |face_unique),
                                 # (1| Dataset),
                      data = subset(db_of7_new, db_of7_new$timebin == timebin_random[b]))

        #store results from the somularion
        # View(simulated_clusters)
            lmer_bin_random_summary<- summary(lmer_bin_random)
            simulated_clusters[i,1]<- timebin_random[b] #save the exact value of time bin
            simulated_clusters[i,2]<- lmer_bin_random_summary[["coefficients"]][2,1] # save the stimate
            simulated_clusters[i,3]<-lmer_bin_random_summary[["coefficients"]][2,4] # t statistic
            simulated_clusters[i,4]<-lmer_bin_random_summary[["coefficients"]][2,5] # p value
            simulated_clusters[i,6]<- nsim[s] #store simulation ount
            simulated_clusters[i,5] <- ifelse(length(lmer_bin_random_summary$optinfo$conv$lme4$message) != 0,
                                               lmer_bin_random_summary$optinfo$conv$lme4$message, 'pass')
              
        # update so that we can store things properly in the big dataset next time
    

     i = i+1
       # 

  }
 }
 
 # Now do clustering of shuffled data, and s
     View(simulated_clusters)
     table(simulated_clusters$cov == 'pass') # check how many convrgence errors we have
#       4489/(4489+35511)
     77/(77+  3923)
     simulated_clusters%>%
       ggplot(aes(t))+
       geom_histogram()
     
       simulated_clusters%>%
       ggplot(aes(timebins, t))+
         # geom_smooth()
        stat_summary(geom = 'line')
         
       geom_histogram()
     
# [1] 0.112225
    simulated_clusters$relgrad<- as.numeric(substr(simulated_clusters$cov,43, 48)) #extract the convergence tol
    simulated_clusters$relgrad_velow<- if_else(simulated_clusters$relgrad< .02, TRUE, FALSE)
     table(simulated_clusters$relgrad_velow)
     # 207/(207+4280) ~ 5 %
     # (4489-4280)/(4489+35511) #so the total non convergence rate is .005 *100 == 0.5%
     
    ### Cluster again on the shuffled data###
     
     # & simulated_clusters$timebins == nbins[b] do we need ti grouo it by timebine
     # for each simulation, cluster timebins
      sum_cluster_sim <- simulated_clusters %>% 
        # filter( simulated_clusters$sim == nsim[s])%>% # pick the current simulation
        arrange(sim, timebins)%>%
        group_by(sim)%>%
        mutate(cluster_shuffle_log = if_else(p < .05, TRUE, FALSE))%>% # create a logical highlighticng signiiant
        # bins
        mutate(Direction = if_else(t > 0 & cluster_shuffle_log == TRUE, "Positive", 
                                  if_else(t < 0 & cluster_shuffle_log == TRUE, "Negative", NULL)))%>% # flag direction that is
        # filter(!is.na(Direction))%>% 
        #significant because later we will need to group by this
      #group_by(cluster_shuffle_log,Direction)%>%
      # below we are creating a counter that that counts only the significant bins, separatelly by whether their are positive or
        #negative to cinfirm if it works 
        group_by(sim)%>%
        mutate(idx = !is.na(Direction))%>%
        mutate(cluster_countershuffle  = as.numeric(replace(Direction, idx, rleid(rleid(Direction)[idx]))))%>%
      # create a cluster t sum by adjacency, remeber the up there we grouped 
      # cluster counter shuffle makes sure ajancent significant bisn are griuped together
      # direction - do we need thisDirection, cluster_shuffle_log 
      group_by(sim, cluster_countershuffle)%>%
      mutate(t_sum_shuffle_dir = sum(t))%>%
      # ungroup()%>%
      mutate(t_sum_shuffle_dir = if_else(cluster_shuffle_log == TRUE, t_sum_shuffle_dir, NULL))%>% #summ timebins into clusters statistics
        # create max cluster lavels, store the direction value of the cluster and the label of the direction
      # suppressWarnings
        group_by(sim)%>%
      mutate(MaxCLust_label = if_else(abs(t_sum_shuffle_dir) == max(abs(t_sum_shuffle_dir), na.rm = TRUE),
                                      cluster_countershuffle, NULL ))%>%
      # suppressWarnings
      mutate(MaxCLust_value = if_else(abs(t_sum_shuffle_dir) == max(abs(t_sum_shuffle_dir), na.rm = TRUE), 
                                      t_sum_shuffle_dir, NULL ))%>%
      # suppressWarnings
      mutate(MaxCLust_direction = if_else(MaxCLust_value > 0, "Positive", "Negative"))%>%
        
        #fill it
      fill(MaxCLust_label, .direction = "updown")%>%
      fill(MaxCLust_value, .direction = "updown")%>%
      fill(MaxCLust_direction, .direction = "updown")
      
      View(sum_cluster_sim)
      # test sim 4 that had a probpem
      sim4<- subset(sum_cluster_sim, sum_cluster_sim$sim == 4)
      View(sim4)
    unique(sum_cluster_sim$MaxCLust_value) 
    
     # a few warnings - invalid factor NA levels = 
 # ma NA = because there is no max that survived significance
    
    
    
```

Compare simulated data with original model
```{r}
simulattion_vs_data<- left_join(sum_cluster_sim, test.data_avgface, by = "timebins")
View(simulattion_vs_data)  


simulattion_vs_data%>%
  mutate(t.obs_sign = if_else(p.y < .05, t.y, NULL))%>%
# simulattion_vs_data %>%
  # ggplot(aes(t.x))+
  ggplot(aes(MaxCLust_value.x))+
  geom_histogram()+
  # geom_histogram(aes(x = t.x))+
  geom_vline(aes(xintercept = t_sum_dir, colour = as.factor(cluster_counter)))+
  geom_vline(aes(xintercept = t.obs_sign))+
  geom_vline(xintercept = -2.374, size = 3, linetype = "dashed")


simulattion_vs_data%>%
  ggplot(aes(timebins, t.x))+
  stat_summary(geom= 'line')+
  stat_summary(aes(y = t.y), geom = 'line')
  
  
  ggplot(aes(t))+
  geom_histogram(fill = 'blue', alpha = .5)

sum_cluster_sim 
mergedtest<- full_join(sum_cluster_sim, test.data_avgface, by = "timebins")

View(mergedtest)

View(test.data_avgface)
View(sum_cluster_sim)

# calculation of propabilities
# p-value for the cluster
# p value is calculated by taking the number of times the sum t statistic was greater than the observed one
simulattion_vs_data<- simulattion_vs_data%>%
    ungroup()%>%
      # group_by(sim,Direction.y) %>%
  fill(MaxCLust_value.y, .direction = "down")%>%
  mutate(MAX_clust_count= if_else(is.na(MaxCLust_value.x) == TRUE,0, 
                                  if_else(abs(!is.na(MaxCLust_value.x))> abs(!is.na(MaxCLust_value.y)), 1, 0)))
View(simulattion_vs_data)

simulattion_vs_data%>%
  ungroup()%>%
  # group_by()
  summarise(p = sum(MAX_clust_count)/n())

plots_of<- list()
plots_of$fullmodel_plot <-
simulattion_vs_data%>%
  mutate(p_boostrap_perm = if_else(cluster_log == TRUE, 0, 1))%>%
  ggplot(aes(timebins, t.y))+
  stat_summary(geom = 'line', size = 2)+
    geom_rect(aes(xmin = timebins, xmax = dplyr::lead(timebins), ymin =5.8 , ymax = 6.1 , fill = p.y),
            alpha = 0.8)+
    geom_text(aes(x = 5, y = 5.8, label = "p uncorrected"),
         # data = presidential,
         size = 3, vjust = 0, hjust = 0, check_overlap = TRUE)+
  
         # data = presidential,
   geom_rect(aes(xmin = timebins, xmax = dplyr::lead(timebins), ymin =5.4 , ymax =5.7 , fill = p_bonf),
             alpha = 0.8)+
    geom_text(aes(x = 5, y = 5.4, label = "p Bonf"),
         # data = presidential,
         size = 3, vjust = 0, hjust = 0, check_overlap = TRUE)+
  geom_rect(aes(xmin = timebins, xmax = dplyr::lead(timebins), ymin =5.0 , ymax =5.3 , fill = p_holm),
             alpha = 0.8)+
    geom_text(aes(x = 5, y = 5.0, label = "p Holm"),
         # data = presidential,
         size = 3, vjust = 0, hjust = 0, check_overlap = TRUE)+
    geom_rect(aes(xmin = timebins, xmax = dplyr::lead(timebins), ymin =4.6, ymax =4.9 , fill = p_boostrap_perm),
            alpha = 0.8)+
  geom_text(aes(x = 5, y = 4.6, label = "Clustering"),
                     size = 3, vjust = 0, hjust = 0, check_overlap = TRUE)+

  scale_fill_viridis_c()+
  theme_minimal()

plots_of$fullmodel_plot<- plots_of$fullmodel_plot +
 scale_x_continuous(limits = c(0,6), breaks = c(0,5))+ 
  # scale_fill_continuous(limits = c(0,5), breaks = c(0,5))+
    scale_fill_viridis_c(limits = c(1,1), breaks = c(0,1))+
  guides(fill = guide_colourbar(ticks = FALSE))
  


```

Plots    
```{r}
View(test.data_avgface)

test.data_avgface$cluster_counter<- if_else(test.data_avgface$cluster == TRUE,test.data_avgface$cluster_counter, NULL)
if_else(test.data_avgface$cluster_counter< 2, as.numeric(test.data_avgface$cluster_counter), as.numeric(test.data_avgface$cluster_counter-1))

test.data_avgface$p_bonf<- p.adjust(test.data_avgface$p, length(test.data_avgface$p), method = "bonferroni")
test.data_avgface$p_holm<- p.adjust(test.data_avgface$p, length(test.data_avgface$p), method = "holm")
  
 View( test.data_avgface) 
 
 
 test.data_avgface<-  test.data_avgface %>%
   mutate(poten_clust = if_else(is.na(cluster_counter) == FALSE & cluster_counter > 0, 0,1))
 
plots_of$avg_global<- test.data_avgface%>%
     ggplot(aes(as.numeric(timebins), t))+
       geom_rect(aes(xmin = timebins, xmax = dplyr::lead(timebins), ymin =4.9, ymax =5.2 , fill = p), 
            alpha = 0.8)+
     geom_rect(aes(xmin = timebins, xmax = dplyr::lead(timebins), ymin =5.7 , ymax =6 , fill = poten_clust),
            alpha = 0.8)+
  geom_rect(aes(xmin = timebins, xmax = dplyr::lead(timebins), ymin =5.3 , ymax =5.6 , fill = p_bonf),
            alpha = 0.8)+
     geom_hline(yintercept = 2, linetype = 'dashed', size = 1.5, colour = 'red')+
     stat_summary(geom = 'line', size = 2)+
               theme_classic()+
     geom_hline(yintercept = -2, linetype = 'dashed', size = 1.5, colour = 'red')+
     stat_summary(geom = 'line', size = 2)+
               theme_classic()+
     geom_hline(yintercept = 0, linetype = 'dashed', size = 1.5, colour = 'gray')+
     stat_summary(geom = 'line', size = 2)+
               theme_classic()+
     # ylim(1,6)+
      scale_fill_viridis_c()+
     scale_fill_viridis_c(breaks= c(0, .5, 1), limits = c(0,1))+
  ggtitle("Global")+
  xlab("Time (s)")+
  ylab("t statistic")



plots_of$avg_global<- plots_of$avg_global+
  p$graphstyle+
  guides(fill = guide_colourbar(ticks = FALSE))+
  scale_y_continuous(breaks = c(-6, 0, 6), limits = c(-6,6))

plots_of$avg_global
```


DO the same for ADFES and JEFFE
```{r}
db_of7_new_JEFFE<- subset(db_of7_new, db_of7_new$Dataset == "JEFFE")
# create an empty dataframe that will hold the information from each test
test.data_avgface_jeffe<- data.frame(timebins= rep(NA, 40), Estimate= rep(NA, 40), t=rep(NA, 40), p=rep(NA, 40), cov= as.character(rep(NA,40)) )


# create a vector with the timebins
timebinout_avg_JEFFE<- unique(db_of7_new_JEFFE$timebin)

# test.data$timebinout<- as.vector(timebinout) # add the curerent timebins to that vector

# empty list of test results
testresults_avg_JEFFE<- list()
# lmer


# i = 15 # currently we have 15 time bins
# the loop below does
# 1 - goes from element i ina  list of eleements 1 to the last time bind_cols
# 2- runs a lmer model regresing face distance to morph vs original, while controling for intercepts of dataset and intercept of unique faces
#3 - stores the result of the model
#4- store informatio on the bin tested, the coeficients, p values and t tests
# morph variance is almost zerp
# dtaset is highly correleted, so ignore

i = 2


for (i in 1:length(timebinout_avg_JEFFE)) {
  testresults_avg_JEFFE<- lmer(log1p(face_action_AVG2 +.1) ~ VideoType_contrast + (1 |face_unique),
                      data = db_of7_new_JEFFE[db_of7_new_JEFFE$timebin == timebinout_avg_JEFFE[i],])
  
   summarytest_avg_JEFFE<- summary(testresults_avg_JEFFE)
   
   test.data_avgface_jeffe[i,1]<-timebinout_avg_JEFFE[i]
   test.data_avgface_jeffe[i,2]<- summarytest_avg_JEFFE[["coefficients"]][2,1]
   test.data_avgface_jeffe[i,3]<-summarytest_avg_JEFFE[["coefficients"]][2,4]
   test.data_avgface_jeffe[i,4]<-summarytest_avg_JEFFE[["coefficients"]][2,5]
   print(i)
   }

summary(testresults_avg_JEFFE)


# now sum adjancet timebins

test.data_avgface_jeffe$p_bonf<- p.adjust(test.data_avgface_jeffe$p, length(test.data_avgface_jeffe$p), method = "bonferroni")
test.data_avgface_jeffe$p_holm<- p.adjust(test.data_avgface_jeffe$p, length(test.data_avgface_jeffe$p), method = "holm")
  
 View( test.data_avgface_jeffe) 
 
 
 View(test.data_avgface_jeffe)
 
 
test.data_avgface_jeffe<- test.data_avgface_jeffe %>%
   mutate(poten_clust = if_else(is.na(cluster_counter) == FALSE & cluster_counter > 0, 0,1))
 
 
plots_of$avg_JEFFE<- test.data_avgface_jeffe %>%
     ggplot(aes(as.numeric(timebins), t))+
  
    geom_rect(aes(xmin = timebins, xmax = dplyr::lead(timebins), ymin =4.9 , ymax =5.2 , fill = p), 
            alpha = 0.8)+
     geom_rect(aes(xmin = timebins, xmax = dplyr::lead(timebins), ymin =5.7 , ymax =6 , fill = poten_clust),
            alpha = 0.8)+
     geom_rect(aes(xmin = timebins, xmax = dplyr::lead(timebins), ymin =5.3 , ymax =5.6 , fill = p_bonf), 
            alpha = 0.8)+

     geom_hline(yintercept = 2, linetype = 'dashed', size = 1.5, colour = 'red')+
     stat_summary(geom = 'line', size = 2)+
               theme_classic()+
  geom_hline(yintercept = -2, linetype = 'dashed', size = 1.5, colour = 'red')+
     stat_summary(geom = 'line', size = 2)+
               theme_classic()+
  geom_hline(yintercept = 0, linetype = 'dashed', size = 1.5, colour = 'gray')+
     stat_summary(geom = 'line', size = 2)+
               theme_classic()+
     # ylim(1,6)+
      # scale_fill_viridis_c()+
  # scale_colour_gradient2(mid = "white", limits = c(0,1), midpoint = .5)+
  scale_fill_viridis_c(breaks= c(0, .5, 1), limits = c(0,1))+
  ggtitle("JEFFE")+
  xlab("Time (s)")+
  ylab("t statistic")

plots_of$avg_JEFFE<- plots_of$avg_JEFFE+ p$graphstyle+
  guides(fill = guide_colourbar(ticks = FALSE))+
  scale_y_continuous(breaks = c(-6, 0, 6), limits = c(-6,6))
  
plots_of$avg_JEFFE
plots_of$avg_Sadness
plots_of$avg_global



  geom_text(aes(x = 5, y = 4.6, label = "Clustering"),
                     size = 3, vjust = 0, hjust = 0, check_overlap = TRUE)+
  

```

Boostrap JEFFE



```{r}
test.data_avgface_jeffe <- test.data_avgface_jeffe %>%
  mutate(cluster_log = if_else(test.data_avgface_jeffe$p< .05, TRUE, FALSE))%>%
  mutate(Direction = if_else(t > 0 & cluster_log == TRUE, "Positive", 
                             if_else(t < 0 & cluster_log == TRUE, "Negative", NULL)))%>% # flag direction that is
        # group_by(sim)%>%
        mutate(idx = !is.na(Direction))%>%
        mutate(cluster_counter  = as.numeric(replace(Direction, idx, rleid(rleid(Direction)[idx]))))%>%
      # create a cluster t sum by adjacency, remeber the up there we grouped 
      # cluster counter shuffle makes sure ajancent significant bisn are griuped together
      # direction - do we need thisDirection, cluster_shuffle_log 
      group_by(cluster_counter)%>%
      mutate(t_sum_dir = sum(t))%>%
      # ungroup()%>%
      mutate(t_sum_dir = if_else(cluster_log == TRUE, t_sum_dir, NULL))%>% #summ timebins into clusters statistics
        # create max cluster lavels, store the direction value of the cluster and the label of the direction
      # suppressWarnings
        # group_by(sim)%>%
      mutate(MaxCLust_label = if_else(abs(t_sum_dir) == max(abs(t_sum_dir), na.rm = TRUE),
                                      cluster_counter, NULL ))%>%
      # suppressWarnings
      mutate(MaxCLust_value = if_else(abs(t_sum_dir) == max(abs(t_sum_dir), na.rm = TRUE), 
                                      t_sum_dir, NULL ))%>%
      # suppressWarnings
      mutate(MaxCLust_direction = if_else(MaxCLust_value > 0, "Positive", "Negative"))
# View(test.data_avgface_jeffe)
# negative estmate = morph has less actiation
        
library(data.table)
# create a counter for helpting with cluster by adjancecy

# regular corrections
test.data_avgface_jeffe<- test.data_avgface_jeffe%>%
  mutate(p_bonf = p.adjust(p, method = 'holm'))%>%
  mutate(p_holm = p.adjust(p, method = "bonf"))


# go back to the data use to fit - db_of7_new[db_of7_new$timestamp == timebinout_avg[i],])
db_of7_new %>%
  filter(Dataset == 'JEFFE')%>%
  group_by(morph)%>%
  summarise(n = n()) # 1920
nrow(db_of7_new_JEFFE)
View(db_of7_new)


i = 1

View(testtemp)
db_of7_new%>%
  filter(Dataset == 'JEFFE')%>%
  group_by(video, morph)%>%
  summarise(time = mean(timebin, na.rm = TRUE))%>%
  group_by(morph)%>%
  summarise(n = n()) # collapsing time now we have 48 vidoe per videotype
              


timebin_shuff_JEFFE<- unique(db_of7_new_JEFFE$timebin)

 # create a random arrangment of labels for oroginal and morpj

nsim = 1:100 #no. of simullation
nbins  =1:40 # numbr of bins. aways check

#create an empty dataframe to store results of the simulation
# remeber to always define it before simulation

simulated_clusters_JEFFE<- data.frame(timebins= rep(NA, max(nsim)*max(nbins)), Estimate= rep(NA, max(nsim)*max(nbins)), t=rep(NA, max(nsim)*max(nbins)), p=rep(NA, max(nsim)*max(nbins)), cov= as.character(rep(NA,max(nsim)*max(nbins))), sim = rep(NA, max(nsim)*max(nbins)) )

# View(simulated_clusters_JEFFE)

timebin_random_JEFFE<- unique(db_of7_new_JEFFE$timebin)

# create random labels

i = 1 # remember to always rezero it
# b = 34

seed = 444

simulated_clusters_JEFFE$cov<- as.character( simulated_clusters_JEFFE$cov) # remeber to run

 i = 1
 # b = 1
 # s = 1
 
 # View(db_of7_new_JEFFE)
 
 db_of7_new_JEFFE$VideoType_contrast<- if_else(db_of7_new_JEFFE$morph == "Morph", -.5, .5) # morph == -.5, original .5

 i = 1
 for (b in 1:length(nbins)) {
  for (s in 1:length(nsim)) {

    message(sprintf("$$$$$RUNING simulation %i & bin %i", nsim[s], nbins[b]))
    db_of7_new_JEFFE$VideoType_contrast_sample<- sample((rep(c(-.5, .5), each =  1920)), replace = FALSE) 
        #run the model on the current time bin and simulation sumber
        lmer_bin_random_JEFFE  <- lmer(face_action_AVG2^2 ~ VideoType_contrast_sample + 
                                   (1 |face_unique),
                      data = subset(db_of7_new_JEFFE, db_of7_new_JEFFE$timebin == timebin_random_JEFFE[b]))

        #store results from the somularion
            lmer_bin_random_summary_JEFFE<- summary(lmer_bin_random_JEFFE)
            simulated_clusters_JEFFE[i,1]<- timebin_random_JEFFE[b] #save the exact value of time bin
            simulated_clusters_JEFFE[i,2]<- lmer_bin_random_summary_JEFFE[["coefficients"]][2,1] # s
            simulated_clusters_JEFFE[i,3]<-lmer_bin_random_summary_JEFFE[["coefficients"]][2,4] # t statistic
            simulated_clusters_JEFFE[i,4]<-lmer_bin_random_summary_JEFFE[["coefficients"]][2,5] # p value
            simulated_clusters_JEFFE[i,6]<- nsim[s] #store simulation ount
            simulated_clusters_JEFFE[i,5] <-ifelse(length(lmer_bin_random_summary_JEFFE$optinfo$conv$lme4$message)
                                                   != 0,
                                               lmer_bin_random_summary_JEFFE$optinfo$conv$lme4$message, 'pass')

     i = i+1
  }
 }
 
 # Now do clustering of shuffled data, and s
     View(simulated_clusters_JEFFE)
     table(simulated_clusters_JEFFE$cov == 'pass') # check how many convrgence errors we have
#       4489/(4489+35511)
     
     simulated_clusters_JEFFE%>%
       ggplot(aes(t))+
       geom_histogram()
     
     
      simulated_clusters%>%
       ggplot(aes(timebins, t))+
         # geom_smooth()
        stat_summary(geom = 'line')
     
       simulated_clusters_JEFFE%>%
       ggplot(aes(timebins, t))+
         # geom_smooth()
        stat_summary(geom = 'line')
         
     
# [1] 0.112225
    simulated_clusters_JEFFE$relgrad<- as.numeric(substr(simulated_clusters_JEFFE$cov,43, 48)) #extract the convergence tol
    simulated_clusters_JEFFE$relgrad_below<- if_else(simulated_clusters_JEFFE$relgrad< .02, TRUE, FALSE)
     table(simulated_clusters_JEFFE$relgrad_below)
     # 3/(61+3) ~ 4 %
     (63)/(4489+35511) #so the total non convergence rate is .001 *100 == 0.1%
     
    ### Cluster again on the shuffled data###
     
     # & simulated_clusters$timebins == nbins[b] do we need ti grouo it by timebine
     # for each simulation, cluster timebins
      sum_cluster_sim_JEFFE <- simulated_clusters_JEFFE %>% 
        # filter( simulated_clusters$sim == nsim[s])%>% # pick the current simulation
        arrange(sim, timebins)%>%
        group_by(sim)%>%
        mutate(cluster_shuffle_log = if_else(p < .05, TRUE, FALSE))%>% # create a logical highlighticng signiiant
        # bins
        mutate(Direction = if_else(t > 0 & cluster_shuffle_log == TRUE, "Positive", 
                                  if_else(t < 0 & cluster_shuffle_log == TRUE, "Negative", NULL)))%>% # flag direction that is
        # filter(!is.na(Direction))%>% 
        #significant because later we will need to group by this
      #group_by(cluster_shuffle_log,Direction)%>%
      # below we are creating a counter that that counts only the significant bins, separatelly by whether their are positive or
        #negative to cinfirm if it works 
        group_by(sim)%>%
        mutate(idx = !is.na(Direction))%>%
        mutate(cluster_countershuffle  = as.numeric(replace(Direction, idx, rleid(rleid(Direction)[idx]))))%>%
      # create a cluster t sum by adjacency, remeber the up there we grouped 
      # cluster counter shuffle makes sure ajancent significant bisn are griuped together
      # direction - do we need thisDirection, cluster_shuffle_log 
      group_by(sim, cluster_countershuffle)%>%
      mutate(t_sum_shuffle_dir = sum(t))%>%
      # ungroup()%>%
      mutate(t_sum_shuffle_dir = if_else(cluster_shuffle_log == TRUE, t_sum_shuffle_dir, NULL))%>% #summ timebins into clusters statistics
        # create max cluster lavels, store the direction value of the cluster and the label of the direction
      # suppressWarnings
        group_by(sim)%>%
      mutate(MaxCLust_label = if_else(abs(t_sum_shuffle_dir) == max(abs(t_sum_shuffle_dir), na.rm = TRUE),
                                      cluster_countershuffle, NULL ))%>%
      # suppressWarnings
      mutate(MaxCLust_value = if_else(abs(t_sum_shuffle_dir) == max(abs(t_sum_shuffle_dir), na.rm = TRUE), 
                                      t_sum_shuffle_dir, NULL ))%>%
      # suppressWarnings
      mutate(MaxCLust_direction = if_else(MaxCLust_value > 0, "Positive", "Negative"))%>%
        
        #fill it
      fill(MaxCLust_label, .direction = "updown")%>%
      fill(MaxCLust_value, .direction = "updown")%>%
      fill(MaxCLust_direction, .direction = "updown")
      
      View(sum_cluster_sim_JEFFE)
      # test sim 4 that had a probpem
      # sim4<- subset(sum_cluster_sim, sum_cluster_sim$sim == 4)
      # View(sim4)
    unique(sum_cluster_sim_JEFFE$MaxCLust_value) 
    
     # a few warnings - invalid factor NA levels = 
 # ma NA = because there is no max that survived sigificance
    View(sum_cluster_sim_JEFFE)
    
    
    sum_cluster_sim_JEFFE%>%
  mutate(MaxCLust_value = if_else(cluster_shuffle_log == TRUE, MaxCLust_value, t))%>%
  ggplot(aes(MaxCLust_value))+
  geom_histogram()
sum_cluster_sim_JEFFE%>%
  mutate(MaxCLust_value = if_else(cluster_shuffle_log == TRUE, MaxCLust_value, NULL))%>%
  ggplot(aes(MaxCLust_value))+
  geom_histogram()
    
View(test.data_avgface_jeffe)

test.data_avgface_jeffe%>%
  # mutate(MaxCLust_value = if_else(cluster_shuffle_log == TRUE, MaxCLust_value, t))%>%
  ggplot(aes(timebins, t))+
  stat_summary(geom = 'line')



# calculation of propabilities
# p-value for the cluster
# p value is calculated by taking the number of times the sum t statistic was greater than the observed one


simulattion_vs_data_JEFFE<- left_join(sum_cluster_sim_JEFFE, test.data_avgface_jeffe, by = 'timebins' )
View(simulattion_vs_data_JEFFE)


simulattion_vs_data_JEFFE<- simulattion_vs_data_JEFFE%>%
    ungroup()%>%
      # group_by(sim,Direction.y) %>%
  fill(MaxCLust_value.y, .direction = "down")%>%
  fill(MaxCLust_direction.y, .direction = "down")%>%
  # fill(MaxCLust_value.y, .direction = "down")%>%
  mutate(MAX_clust_count= if_else(is.na(MaxCLust_value.x) == TRUE,0, 
                                  if_else(abs(!is.na(MaxCLust_value.x))> abs(!is.na(MaxCLust_value.y)), 1, 0)))


# I think we need to take the clusters to columns (SPREAD)
# How many clusters did we have in the data
unique(simulattion_vs_data_JEFFE$cluster_counter)
simulattion_vs_data_JEFFE  <- simulattion_vs_data_JEFFE %>%
  # group_by(cluster_counter)%>%
  mutate(cluster1_tsum = if_else(cluster_counter == 1, t_sum_dir, NULL))%>%
  mutate(cluster1_direction = if_else(cluster_counter == 1, MaxCLust_direction.y, NULL))%>%
  mutate(cluster2_tsum = if_else(cluster_counter == 2, t_sum_dir, NULL))%>%
  mutate(cluster2_direction = if_else(cluster_counter == 2, MaxCLust_direction.y, NULL))%>%
  mutate(cluster3_tsum = if_else(cluster_counter == 3, t_sum_dir, NULL))%>%
  mutate(cluster3_direction = if_else(cluster_counter == 3,MaxCLust_direction.y, NULL))%>%
  fill(cluster1_tsum, .direction = 'updown')%>%
  fill(cluster2_tsum, .direction = 'updown')%>%
  fill(cluster3_tsum, .direction = 'updown')%>%
  fill(cluster1_direction , .direction = 'updown')%>%
  fill(cluster2_direction , .direction = 'updown')%>%
  fill(cluster3_direction , .direction = 'updown')

View(simulattion_vs_data_JEFFE)


unique(simulattion_vs_data$MAX_clust_count)
View(simulattion_vs_data_JEFFE)
#  i think we need to tae the t value when the simulations are not significant
table(is.na(simulattion_vs_data_JEFFE$t_sum_shuffle_dir))
 simulattion_vs_data_JEFFE <-  simulattion_vs_data_JEFFE %>%
   
  mutate(Max_clust_value_and_ns_t = if_else(is.na(t_sum_shuffle_dir), t.x, t_sum_shuffle_dir))%>%
  mutate(Max_clust_value_and_ns_t_jelka = t_sum_shuffle_dir)%>%
  mutate(Clust1_sim_biggerthan_data = if_else(abs(Max_clust_value_and_ns_t)> abs(cluster1_tsum), 1,0))%>%
  mutate(Clust2_sim_biggerthan_data = if_else(abs(Max_clust_value_and_ns_t)> abs(cluster2_tsum), 1,0))%>%
  mutate(Clust3_sim_biggerthan_data = if_else(abs(Max_clust_value_and_ns_t)> abs(cluster3_tsum), 1,0))%>%
   
  mutate(Clust1_sim_biggerthan_data1 = if_else(abs(Max_clust_value_and_ns_t_jelka)> abs(cluster1_tsum), 1,0))%>%
  mutate(Clust2_sim_biggerthan_data2 = if_else(abs(Max_clust_value_and_ns_t_jelka)> abs(cluster2_tsum), 1,0))%>%
  mutate(Clust3_sim_biggerthan_data3 = if_else(abs(Max_clust_value_and_ns_t_jelka)> abs(cluster3_tsum), 1,0))%>%

  # mutate(Clust2_sim_biggerthan_data = if_else(abs(Max_clust_value_and_ns_t) > abs(cluster2_tsum), 1,0))%>%
  mutate(clust1_p =  sum(Clust1_sim_biggerthan_data)/n())%>%
  mutate(clust2_p =  sum(Clust2_sim_biggerthan_data)/n())%>%
  mutate(clust3_p =  sum(Clust3_sim_biggerthan_data)/n())%>%
   
  mutate(clust1_p_jelka =  sum(Clust1_sim_biggerthan_data)/2001)%>%
  mutate(clust2_p_jelka =  sum(Clust2_sim_biggerthan_data)/2001)%>%
  mutate(clust3_p_jelka =  sum(Clust3_sim_biggerthan_data)/2001)
 # get p values
p_values_JEFFE<- 
  simulattion_vs_data_JEFFE %>%
  # subset(simulattion_vs_data_JEFFE, is.na(as.factor(simulattion_vs_data_JEFFE$cluster_counter)))%%
  group_by(cluster_counter)%>%
  summarise_at(c('clust1_p', 'clust2_p', 'clust3_p', 'clust1_p_jelka', 'clust2_p_jelka', 'clust3_p_jelka'), mean, na.rm = TRUE)

p_values_JEFFE
test.data_avgface_jeffe<-left_join(test.data_avgface_jeffe, p_values_JEFFE)

View(test.data_avgface_jeffe)

plots_of$JEFFE_full<- test.data_avgface_jeffe$%>%
  mutate(p_clustering =  if_else(is.na(cluster_counter),1,
                                 if_else(cluster_counter == 1, clust1_p,
                                         if_else(cluster_counter == 2, clust2_p,
                                                 if_else(cluster_counter == 3, clust3_p,
                                                         NULL)))))%>%
     ggplot(aes(as.numeric(timebins), t))+
     geom_rect(aes(xmin = timebins, xmax = dplyr::lead(timebins), ymin =5.8 , ymax =6 , fill = p),
            alpha = 0.8)+
  geom_text(aes(x = 5, y = 5.8, label = "p uncorrected",
                size = 3, vjust = 0, hjust = 0, check_overlap = TRUE))+

  geom_rect(aes(xmin = timebins, xmax = dplyr::lead(timebins), ymin =5.4 , ymax =5.7 , fill = p_holm),
            alpha = 0.8)+
     geom_text(aes(x = 5, y = 5.4, label = "p Holm",
                size = 3, vjust = 0, hjust = 0, check_overlap = TRUE))+
     geom_rect(aes(xmin = timebins, xmax = dplyr::lead(timebins), ymin =5, ymax =5.3 , fill = p_bonf), 
            alpha = 0.8)+
     geom_text(aes(x = 5, y = 5, label = "p Bonf",
                size = 3, vjust = 0, hjust = 0, check_overlap = TRUE))+
  geom_rect(aes(xmin = timebins, xmax = dplyr::lead(timebins), ymin =4.6, ymax =4.9 , fill = p_clustering), 
            alpha = 0.8)+
     geom_text(aes(x = 5, y = 4.6, label = "Clustering",
                size = 3, vjust = 0, hjust = 0, check_overlap = TRUE))+
     geom_hline(yintercept = 0, linetype = 'dashed', size = 1.5, colour = 'red')+
  geom_hline(yintercept = 1.96, linetype = 'dashed', size = 1, colour = 'red')+
   geom_hline(yintercept = -1.96, linetype = 'dashed', size = 1.5, colour = 'red')+
     stat_summary(geom = 'line', size = 2)+
               theme_classic()+
     # ylim(1,6)+
      scale_fill_viridis_c()+
     scale_colour_gradient2(mid = "white", limits = c(0,1), midpoint = .5)+
  ggtitle("JEFFE")

plots_of$JEFFE_full<- plots_of$JEFFE_full+
  p$paper +
   scale_x_continuous(limits = c(0,6), breaks = c(0,5))+ 
  # scale_fill_continuous(limits = c(0,5), breaks = c(0,5))+
    scale_fill_viridis_c(limits = c(0,.1), breaks = c(0,1))+
  guides(fill = guide_colourbar(ticks = FALSE))

plots_of$JEFFE_full  


test.data_avgface_jeffe%>%
  ggplot(aes(timebins,t))+
  geom_line()+
  geom_rect(aes(xmin = timebins, xmax = dplyr::lead(timebins), ymin =5.8 , ymax =6 , fill = p))
```
    

```{r}
simulattion_vs_data%>%
  mutate(p_boostrap_perm = if_else(cluster_log == TRUE, 0, 1))%>%
  ggplot(aes(timebins, t.y))+
  stat_summary(geom = 'line')+
  geom_rect(aes(xmin = timebins, xmax = dplyr::lead(timebins), ymin =4.6 , ymax =4.9 , fill = p_boostrap_perm),
            alpha = 0.8)+
  geom_text(aes(x = 5, y = 4.6, label = "CBP"),
         # data = presidential,
         size = 3, vjust = 0, hjust = 0, check_overlap = TRUE)+
   geom_rect(aes(xmin = timebins, xmax = dplyr::lead(timebins), ymin =5.8 , ymax =6.1 , fill = p_bonf),
             alpha = 0.8)+
    geom_text(aes(x = 5, y = 5.8, label = "Bonf"),
         # data = presidential,
         size = 3, vjust = 0, hjust = 0, check_overlap = TRUE)+
  geom_rect(aes(xmin = timebins, xmax = dplyr::lead(timebins), ymin =5.4 , ymax =5.7 , fill = p_holm),
             alpha = 0.8)+
    geom_text(aes(x = 5, y = 5.4, label = "Holm"),
         # data = presidential,
         size = 3, vjust = 0, hjust = 0, check_overlap = TRUE)+
  geom_rect(aes(xmin = timebins, xmax = dplyr::lead(timebins), ymin =5.0 , ymax = 5.3 , fill = p.y),
            alpha = 0.8)+
    geom_text(aes(x = 5, y = 5.0, label = "p"),
         # data = presidential,
         size = 3, vjust = 0, hjust = 0, check_overlap = TRUE)+
  scale_fill_viridis_c()+
  theme_minimal()



```


ADFES - AVG face

```{r}

db_of7_new_ADFES<- subset(db_of7_new, db_of7_new$Dataset == "ADFES")
# create an empty dataframe that will hold the information from each test
test.data_avgface_ADFES<- data.frame(timebins= rep(NA, 40), Estimate= rep(NA, 40), t=rep(NA, 40), p=rep(NA, 40), cov= as.character(rep(NA,40)) )


# create a vector with the timebins
timebinout_avg_ADFES<- unique(db_of7_new_ADFES$timestamp)

# test.data$timebinout<- as.vector(timebinout) # add the curerent timebins to that vector

# empty list of test results
testresults_avg_ADFES<- list()
# lmer


i = 15 # currently we have 15 time bins
# the loop below does
# 1 - goes from element i ina  list of eleements 1 to the last time bind_cols
# 2- runs a lmer model regresing face distance to morph vs original, while controling for intercepts of dataset and intercept of unique faces
#3 - stores the result of the model
#4- store informatio on the bin tested, the coeficients, p values and t tests
# morph variance is almost zerp
# dtaset is highly correleted, so ignore

i = 1


for (i in 1:length(timebinout_avg_ADFES)) {
  testresults_avg_ADFES<- lmer(face_action_AVG2* ~ VideoType_contrast + (1 |face_unique),
                      data = db_of7_new_ADFES[db_of7_new_ADFES$timestamp == timebinout_avg_ADFES[i],])

  # testresults<- lmer(log1p(D1+.1) ~ morph + (1|face_unique),
  #                     data = db_of8 [db_of8$timebin == timebinout[i] & db_of8$Dataset !="ADFES",])
   summarytest_avg_ADFES<- summary(testresults_avg_ADFES)
   
   test.data_avgface_ADFES[i,1]<-timebinout_avg_ADFES[i]
  test.data_avgface_ADFES[i,2]<- summarytest_avg_ADFES[["coefficients"]][2,1]
   test.data_avgface_ADFES[i,3]<-summarytest_avg_ADFES[["coefficients"]][2,4]
   test.data_avgface_ADFES[i,4]<-summarytest_avg_ADFES[["coefficients"]][2,5]
   # test.data[i,5]<- testresults@optinfo$val
   print(i)
   }

summary(testresults_avg_ADFES)


# now sum adjancet timebins

test.data_avgface_ADFES$p_bonf<- p.adjust(test.data_avgface_ADFES$p, length(test.data_avgface_ADFES$p), method = "bonferroni")
test.data_avgface_ADFES$p_holm<- p.adjust(test.data_avgface_ADFES$p, length(test.data_avgface_ADFES$p), method = "holm")
  
 View( test.data_avgface_ADFES) 
 
 test.data_avgface_ADFES<- test.data_avgface_ADFES %>%
   mutate(poten_clust = if_else(is.na(cluster_counter) == FALSE & cluster_counter > 0, 0,1))
 
 
plots_of$avg_ADFES <- test.data_avgface_ADFES %>%
     ggplot(aes(as.numeric(timebins), t))+
     geom_rect(aes(xmin = timebins, xmax = dplyr::lead(timebins), ymin =5.8 , ymax =6 , fill = p),
            alpha = 0.8)+
  geom_rect(aes(xmin = timebins, xmax = dplyr::lead(timebins), ymin =4.9 , ymax =5.2 , fill = p), 
            alpha = 0.8)+
     geom_rect(aes(xmin = timebins, xmax = dplyr::lead(timebins), ymin =5.7 , ymax =6 , fill = poten_clust),
            alpha = 0.8)+
     geom_rect(aes(xmin = timebins, xmax = dplyr::lead(timebins), ymin =5.3 , ymax =5.6 , fill = p_bonf), 
            alpha = 0.8)+

     geom_hline(yintercept = 2, linetype = 'dashed', size = 1.5, colour = 'red')+
     stat_summary(geom = 'line', size = 2)+
               theme_classic()+
  geom_hline(yintercept = -2, linetype = 'dashed', size = 1.5, colour = 'red')+
     stat_summary(geom = 'line', size = 2)+
               theme_classic()+
  geom_hline(yintercept = 0, linetype = 'dashed', size = 1.5, colour = 'gray')+
     stat_summary(geom = 'line', size = 2)+
               theme_classic()+
     # ylim(1,6)+
      # scale_fill_viridis_c()+
  # scale_colour_gradient2(mid = "white", limits = c(0,1), midpoint = .5)+
  scale_fill_viridis_c(breaks= c(0, .5, 1), limits = c(0,1))+
  ggtitle("ADFES")+
  xlab("Time (s)")+
  ylab("t statistic")

plots_of$avg_ADFES
plots_of$avg_ADFES<- plots_of$avg_ADFES+ p$graphstyle+
  guides(fill = guide_colourbar(ticks = FALSE))+
  scale_y_continuous(breaks = c(-2, 2, 6), limits = c(-3,6))

plots_of$avg_ADFES<- plots_of$avg_ADFES+ p$paper+
   scale_x_continuous(limits = c(0,6), breaks = c(0,5))+ 
  # scale_fill_continuous(limits = c(0,5), breaks = c(0,5))+
    scale_fill_viridis_c(limits = c(0,1), breaks = c(0,1))+
  guides(fill = guide_colourbar(ticks = FALSE))
plots_of$avg_global

plots_of$avg_ADFES




```


Boostrap ADFES



```{r}

test.data_avgface_ADFES <- test.data_avgface_ADFES %>%
  mutate(cluster_log = if_else(test.data_avgface_ADFES$p< .1, TRUE, FALSE))%>%
  mutate(Direction = if_else(t > 0 & cluster_log == TRUE, "Positive", 
                             if_else(t < 0 & cluster_log == TRUE, "Negative", NULL)))%>% # flag direction that is
        # group_by(sim)%>%
        mutate(idx = !is.na(Direction))%>%
        mutate(cluster_counter  = as.numeric(replace(Direction, idx, rleid(rleid(Direction)[idx]))))%>%
      # create a cluster t sum by adjacency, remeber the up there we grouped 
      # cluster counter shuffle makes sure ajancent significant bisn are griuped together
      # direction - do we need thisDirection, cluster_shuffle_log 
      group_by(cluster_counter)%>%
      mutate(t_sum_dir = sum(t))%>%
      # ungroup()%>%
      mutate(t_sum_dir = if_else(cluster_log == TRUE, t_sum_dir, NULL))%>% #summ timebins into clusters statistics
        # create max cluster lavels, store the direction value of the cluster and the label of the direction
      # suppressWarnings
        # group_by(sim)%>%
      mutate(MaxCLust_label = if_else(abs(t_sum_dir) == max(abs(t_sum_dir), na.rm = TRUE),
                                      cluster_counter, NULL ))%>%
      # suppressWarnings
      mutate(MaxCLust_value = if_else(abs(t_sum_dir) == max(abs(t_sum_dir), na.rm = TRUE), 
                                      t_sum_dir, NULL ))%>%
      # suppressWarnings
      mutate(MaxCLust_direction = if_else(MaxCLust_value > 0, "Positive", "Negative"))
View(test.data_avgface_ADFES)
# negative estmate = morph has less actiation
        
library(data.table)
# create a counter for helpting with cluster by adjancecy

# regular corrections
# test.data_avgface_ADFES<- test.data_avgface_ADFES%>%
#   mutate(p_bonf = p.adjust(p, method = 'holm'))%>%
#   mutate(p_holm = p.adjust(p, method = "bonf"))


# go back to the data use to fit - db_of7_new[db_of7_new$timestamp == timebinout_avg[i],])
db_of7_new %>%
  filter(Dataset == 'ADFES')%>%
  group_by(morph)%>%
  summarise(n = n()) # 1920

View(db_of7_new)

i = 1

View(testtemp)

db_of7_new%>%
  filter(Dataset == 'ADFES')%>%
  group_by(video, morph)%>%
  summarise(time = mean(timebin, na.rm = TRUE))%>%
  group_by(morph)%>%
  summarise(n = n()) # collapsing time now we have 48 vidoe per videotype
              

timebin_shuff_ADFES<- unique(db_of7_new_ADFES$timebin)

 # create a random arrangment of labels for oroginal and morpj

nsim = 1:1000 #no. of simullation
nbins  =1:40 # numbr of bins. aways check

#create an empty dataframe to store results of the simulation
# remeber to always define it before simulation

simulated_clusters_ADFES<- data.frame(timebins= rep(NA, max(nsim)*max(nbins)), Estimate= rep(NA, max(nsim)*max(nbins)), t=rep(NA, max(nsim)*max(nbins)), p=rep(NA, max(nsim)*max(nbins)), cov= as.character(rep(NA,max(nsim)*max(nbins))), sim = rep(NA, max(nsim)*max(nbins)) )

View(simulated_clusters_ADFES)

timebin_random_ADFES<- unique(db_of7_new_ADFES$timebin)

# create random labels

i = 1 # remember to always rezero it
# b = 34

seed = 444

simulated_clusters_ADFES$cov<- as.character( simulated_clusters_ADFES$cov) # remeber to run

 i = 1
 # b = 1
 # s = 1
 
 View(db_of7_new_ADFES)
 
 db_of7_new_ADFES$VideoType_contrast<- if_else(db_of7_new_ADFES$morph == "Morph", -.5, .5) # morph == -.5, original .5

 i = 1

for (b in 1:length(nbins)) {
  for (s in 1:length(nsim)) {

    message(sprintf("$$$$$RUNING simulation %i & bin %i", nsim[s], nbins[b]))
    db_of7_new_ADFES$VideoType_contrast_sample<- sample((rep(c(-.5, .5), each =  1920)), replace = FALSE) 
        #run the model on the current time bin and simulation sumber
        lmer_bin_random_ADFES  <- lmer(log1p(face_action_AVG +.1) ~ VideoType_contrast_sample + 
                                   (1 |face_unique),
                      data = subset(db_of7_new_ADFES, db_of7_new_ADFES$timebin == timebin_random_ADFES[b]))

        #store results from the somularion
            lmer_bin_random_summary_ADFES<- summary(lmer_bin_random_ADFES)
            simulated_clusters_ADFES[i,1]<- timebin_random_ADFES[b] #save the exact value of time bin
            simulated_clusters_ADFES[i,2]<- lmer_bin_random_summary_ADFES[["coefficients"]][2,1] # s
            simulated_clusters_ADFES[i,3]<-lmer_bin_random_summary_ADFES[["coefficients"]][2,4] # t statistic
            simulated_clusters_ADFES[i,4]<-lmer_bin_random_summary_ADFES[["coefficients"]][2,5] # p value
            simulated_clusters_ADFES[i,6]<- nsim[s] #store simulation ount
            simulated_clusters_ADFES[i,5] <-ifelse(length(lmer_bin_random_summary_ADFES$optinfo$conv$lme4$message)
                                                   != 0,
                                               lmer_bin_random_summary_ADFES$optinfo$conv$lme4$message, 'pass')

     i = i+1
  }
}



```

ADFES boostrap clustering

```{r}

 # Now do clustering of shuffled data, and s
     View(simulated_clusters_ADFES)
     table(simulated_clusters_ADFES$cov == 'pass') # check how many convrgence errors we have
#       4489/(4489+35511)
     
     simulated_clusters_ADFES%>%
       ggplot(aes(t))+
       geom_histogram()
     

      simulated_clusters_ADFES%>%
       ggplot(aes(timebins, t))+
         geom_line(aes(group = sim))+
        stat_summary(geom = 'line')

         
# [1] 0.112225
    simulated_clusters_ADFES$relgrad<- as.numeric(substr(simulated_clusters_ADFES$cov,43, 48)) #extract the convergence tol
    simulated_clusters_ADFES$relgrad_below<- if_else(simulated_clusters_ADFES$relgrad< .02, TRUE, FALSE)
     table(simulated_clusters_ADFES$relgrad_below)
     # 3/(61+3) ~ 4 %
     # (63)/(4489+35511) #so the total non convergence rate is .001 *100 == 0.1%
     
    ### Cluster again on the shuffled data###
     
     # & simulated_clusters$timebins == nbins[b] do we need ti grouo it by timebine
     # for each simulation, cluster timebins
      sum_cluster_sim_ADFES <- simulated_clusters_ADFES %>% 
        # filter( simulated_clusters$sim == nsim[s])%>% # pick the current simulation
        arrange(sim, timebins)%>%
        group_by(sim)%>%
        mutate(cluster_shuffle_log = if_else(p < .05, TRUE, FALSE))%>% # create a logical highlighticng signiiant
        # bins
        mutate(Direction = if_else(t > 0 & cluster_shuffle_log == TRUE, "Positive", 
                                  if_else(t < 0 & cluster_shuffle_log == TRUE, "Negative", NULL)))%>% # flag direction that is
        # filter(!is.na(Direction))%>% 
        #significant because later we will need to group by this
      #group_by(cluster_shuffle_log,Direction)%>%
      # below we are creating a counter that that counts only the significant bins, separatelly by whether their are positive or
        #negative to cinfirm if it works 
        group_by(sim)%>%
        mutate(idx = !is.na(Direction))%>%
        mutate(cluster_countershuffle  = as.numeric(replace(Direction, idx, rleid(rleid(Direction)[idx]))))%>%
      # create a cluster t sum by adjacency, remeber the up there we grouped 
      # cluster counter shuffle makes sure ajancent significant bisn are griuped together
      # direction - do we need thisDirection, cluster_shuffle_log 
      group_by(sim, cluster_countershuffle)%>%
      mutate(t_sum_shuffle_dir = sum(t))%>%
      # ungroup()%>%
      mutate(t_sum_shuffle_dir = if_else(cluster_shuffle_log == TRUE, t_sum_shuffle_dir, NULL))%>% #summ timebins into clusters statistics
        # create max cluster lavels, store the direction value of the cluster and the label of the direction
      # suppressWarnings
        group_by(sim)%>%
      mutate(MaxCLust_label = if_else(abs(t_sum_shuffle_dir) == max(abs(t_sum_shuffle_dir), na.rm = TRUE),
                                      cluster_countershuffle, NULL ))%>%
      # suppressWarnings
      mutate(MaxCLust_value = if_else(abs(t_sum_shuffle_dir) == max(abs(t_sum_shuffle_dir), na.rm = TRUE), 
                                      t_sum_shuffle_dir, NULL ))%>%
      # suppressWarnings
      mutate(MaxCLust_direction = if_else(MaxCLust_value > 0, "Positive", "Negative"))%>%
        
        #fill it
      fill(MaxCLust_label, .direction = "updown")%>%
      fill(MaxCLust_value, .direction = "updown")%>%
      fill(MaxCLust_direction, .direction = "updown")
      
      View(sum_cluster_sim_ADFES)
      # test sim 4 that had a probpem
      # sim4<- subset(sum_cluster_sim, sum_cluster_sim$sim == 4)
      # View(sim4)
    unique(sum_cluster_sim_ADFES$MaxCLust_value) 
    
     # a few warnings - invalid factor NA levels = 
 # ma NA = because there is no max that survived sigificance

    
    sum_cluster_sim_ADFES%>%
  mutate(MaxCLust_value = if_else(cluster_shuffle_log == TRUE, MaxCLust_value, t))%>%
  ggplot(aes(MaxCLust_value))+
  geom_histogram()
sum_cluster_sim_ADFES%>%
  mutate(MaxCLust_value = if_else(cluster_shuffle_log == TRUE, MaxCLust_value, NULL))%>%
  ggplot(aes(MaxCLust_value))+
  geom_histogram()
    
View(sum_cluster_sim_ADFES)

```

computing pvalues for ADFES boostrap

```{r}
# calculation of propabilities
# p-value for the cluster
# p value is calculated by taking the number of times the sum t statistic was greater than the observed one

View(sum_cluster_sim_ADFES)
View( test.data_avgface_ADFES)
sum_cluster_sim_ADFES$timebins1<- substr((sum_cluster_sim_ADFES$timebins+.06),1,3)
test.data_avgface_ADFES$timebins1<-substr( test.data_avgface_ADFES$timebins,1,3)

simulattion_vs_data_ADFES<- left_join(sum_cluster_sim_ADFES, test.data_avgface_ADFES, by =
                                        c('timebins1'))
View(simulattion_vs_data_ADFES)


simulattion_vs_data_ADFES<- simulattion_vs_data_ADFES%>%
    ungroup()%>%
      # group_by(sim,Direction.y) %>%
  fill(MaxCLust_value.y, .direction = "down")%>%
  fill(MaxCLust_direction.y, .direction = "down")%>%
  # fill(MaxCLust_value.y, .direction = "down")%>%
  mutate(MAX_clust_count= if_else(is.na(MaxCLust_value.x) == TRUE,0, 
                                  if_else(abs(!is.na(MaxCLust_value.x))> abs(!is.na(MaxCLust_value.y)), 1, 0)))


# I think we need to take the clusters to columns (SPREAD)
# How many clusters did we have in the data
unique(simulattion_vs_data_ADFES$cluster_counter)
simulattion_vs_data_ADFES  <- simulattion_vs_data_ADFES %>%
  # group_by(cluster_counter)%>%
  mutate(cluster1_tsum = if_else(cluster_counter == 1, t_sum_dir, NULL))%>%
  mutate(cluster1_direction = if_else(cluster_counter == 1, MaxCLust_direction.y, NULL))%>%
  mutate(cluster2_tsum = if_else(cluster_counter == 2, t_sum_dir, NULL))%>%
  mutate(cluster2_direction = if_else(cluster_counter == 2, MaxCLust_direction.y, NULL))%>%
  mutate(cluster3_tsum = if_else(cluster_counter == 3, t_sum_dir, NULL))%>%
  mutate(cluster3_direction = if_else(cluster_counter == 3,MaxCLust_direction.y, NULL))%>%
  fill(cluster1_tsum, .direction = 'updown')%>%
  fill(cluster2_tsum, .direction = 'updown')%>%
  fill(cluster3_tsum, .direction = 'updown')%>%
  fill(cluster1_direction , .direction = 'updown')%>%
  fill(cluster2_direction , .direction = 'updown')%>%
  fill(cluster3_direction , .direction = 'updown')

View(simulattion_vs_data_ADFES)


unique(simulattion_vs_data$MAX_clust_count)
View(simulattion_vs_data_ADFES)
#  i think we need to tae the t value when the simulations are not significant
table(is.na(simulattion_vs_data_ADFES$t_sum_shuffle_dir))
 simulattion_vs_data_ADFES <-  simulattion_vs_data_ADFES %>%
   
  mutate(Max_clust_value_and_ns_t = if_else(is.na(t_sum_shuffle_dir), t.x, t_sum_shuffle_dir))%>%
  mutate(Max_clust_value_and_ns_t_jelka = t_sum_shuffle_dir)%>%
  mutate(Clust1_sim_biggerthan_data = if_else(abs(Max_clust_value_and_ns_t)> abs(cluster1_tsum), 1,0))%>%
  mutate(Clust2_sim_biggerthan_data = if_else(abs(Max_clust_value_and_ns_t)> abs(cluster2_tsum), 1,0))%>%
  # mutate(Clust3_sim_biggerthan_data = if_else(abs(Max_clust_value_and_ns_t)> abs(cluster3_tsum), 1,0))%>%
   
  mutate(Clust1_sim_biggerthan_data1 = if_else(abs(Max_clust_value_and_ns_t_jelka)> abs(cluster1_tsum), 1,0))%>%
  mutate(Clust2_sim_biggerthan_data2 = if_else(abs(Max_clust_value_and_ns_t_jelka)> abs(cluster2_tsum), 1,0))%>%
  # mutate(Clust3_sim_biggerthan_data3 = if_else(abs(Max_clust_value_and_ns_t_jelka)> abs(cluster3_tsum), 1,0))%>%

  # mutate(Clust2_sim_biggerthan_data = if_else(abs(Max_clust_value_and_ns_t) > abs(cluster2_tsum), 1,0))%>%
  mutate(clust1_p =  sum(Clust1_sim_biggerthan_data)/n())%>%
  mutate(clust2_p =  sum(Clust2_sim_biggerthan_data)/n())%>%
  # mutate(clust3_p =  sum(Clust3_sim_biggerthan_data)/n())%>%
   
  mutate(clust1_p_jelka =  sum(Clust1_sim_biggerthan_data)/2001)%>%
  mutate(clust2_p_jelka =  sum(Clust2_sim_biggerthan_data)/2001)
  # mutate(clust3_p_jelka =  sum(Clust3_sim_biggerthan_data)/2001)
 # get p values
p_values_ADFES<- 
  simulattion_vs_data_ADFES %>%
  # subset(simulattion_vs_data_ADFES, is.na(as.factor(simulattion_vs_data_ADFES$cluster_counter)))%%
  group_by(cluster_counter)%>%
  summarise_at(c('clust1_p', 'clust2_p', 'clust3_p', 'clust1_p_jelka', 'clust2_p_jelka', 'clust3_p_jelka'), mean, na.rm = TRUE)

p_values_ADFES
test.data_avgface_ADFES<-left_join(test.data_avgface_ADFES, p_values_ADFES)

View(test.data_avgface_ADFES)
test.data_avgface_ADFES<- test.data_avgface_ADFES%>%
  mutate(p_clustering =  if_else(is.na(cluster_counter),1,
                                 if_else(cluster_counter == 1, clust1_p,
                                         if_else(cluster_counter == 2, clust2_p,
                                                 # if_else(cluster_counter == 3, clust3_p,
                                                         NULL))))
plots_of$ADFES_bbostrap<- test.data_avgface_ADFES%>%  
ggplot(aes(as.numeric(timebins), t))+
     geom_rect(aes(xmin = timebins, xmax = dplyr::lead(timebins), ymin =5.8 , ymax =6 , fill = p),
            alpha = 0.8)+
  geom_text(aes(x = 5, y = 5.8, label = "p uncorrectected",
                size = 3, vjust = 0, hjust = 0, check_overlap = TRUE))+

  geom_rect(aes(xmin = timebins, xmax = dplyr::lead(timebins), ymin =5.4 , ymax =5.7 , fill = p_holm),
            alpha = 0.8)+
     geom_text(aes(x = 5, y = 5.4, label = "p Holm",
                size = 3, vjust = 0, hjust = 0, check_overlap = TRUE))+
     geom_rect(aes(xmin = timebins, xmax = dplyr::lead(timebins), ymin =5, ymax =5.3 , fill = p_bonf), 
            alpha = 0.8)+
     geom_text(aes(x = 5, y = 5, label = "p Bonf",
                size = 3, vjust = 0, hjust = 0, check_overlap = TRUE))+
  geom_rect(aes(xmin = timebins, xmax = dplyr::lead(timebins), ymin =4.6, ymax =4.9 , fill = p_clustering), 
            alpha = 0.8)+
     geom_text(aes(x = 5, y = 4.6, label = "p Cluster",
                size = 3, vjust = 0, hjust = 0, check_overlap = TRUE))+
     geom_hline(yintercept = 0, linetype = 'dashed', size = 1.5, colour = 'red')+
  geom_hline(yintercept = 1.96, linetype = 'dashed', size = 1, colour = 'red')+
   geom_hline(yintercept = -1.96, linetype = 'dashed', size = 1.5, colour = 'red')+
     stat_summary(geom = 'line', size = 2)+
               theme_classic()+
     # ylim(1,6)+
      scale_fill_viridis_c()+
     scale_colour_gradient2(mid = "white", limits = c(0,1), midpoint = .5)+
  ggtitle("ADFES - Average Face action ~ Morph")

plots_of$ADFES_bbostrap

```


By emotion now
Anger

```{r}

# db_of7_new$Emotion
db_of7_new_avg_Anger<- subset(db_of7_new, db_of7_new$Emotion == "Anger")



test.data_by_avg_Anger<- data.frame(timebins= rep(NA, 40), Estimate= rep(NA, 40), t=rep(NA, 40), p=rep(NA, 40), cov= as.character(rep(NA,40)) )

timebin_avg_Anger<- unique(db_of7_new_avg_Anger$timebin)
# test.data$timebinout<- as.vector(timebinout) # add the curerent timebins to that vector

# empty list of test results
testresults_avg_Anger<- list()
# lmer


# currently we have 15 time bins
# the loop below does
# 1 - goes from element i ina  list of eleements 1 to the last time bind_cols
# 2- runs a lmer model regresing face distance to morph vs original, while controling for intercepts of dataset and intercept of unique faces
#3 - stores the result of the model
#4- store informatio on the bin tested, the coeficients, p values and t tests
# morph variance is almost zerp
# dtaset is highly correleted, so ignore


i = 1
for (i in 1:length(timestamp_avg_Anger)) {
  # Surprise_results<- t.test(log1p(D1+.1) ~ morph,var.equal = FALSE, paired = FALSE, data = db_of7_new[db_of7_new$timestamp == timebinout[i],])
  avg_Anger_results<- lmer(log1p(D1+.1) ~ VideoType_contrast + (1 |face_unique) + (1 | Dataset),
                      data = db_of7_new_avg_Anger[db_of7_new_avg_Anger$timebin == timebin_avg_Anger[i],])

  # testresults<- lmer(log1p(D1+.1) ~ morph + (1|face_unique),
  #                     data = db_of7_new [db_of7_new$timebin == timebinout[i] & db_of7_new$Dataset !="ADFES",])
  avg_Anger_results_sum<- summary(avg_Anger_results)

   test.data_by_avg_Anger[i,1]<-timestamp_avg_Anger[i]
   test.data_by_avg_Anger[i,2]<- avg_Anger_results_sum[["coefficients"]][2,1]
   test.data_by_avg_Anger[i,3]<- avg_Anger_results_sum[["coefficients"]][2,4]
   test.data_by_avg_Anger[i,4]<- avg_Anger_results_sum[["coefficients"]][2,5]
  #
   
   
  #     test.data_bySurprise[i,1]<-timestamp_Surprise[i]
  # # test.data_bySurprise[i,2]<- Surprise_results_sum[["coefficients"]][2,1]
  #  test.data_bySurprise[i,3]<- Surprise_results$statistic
  #  test.data_bySurprise[i,4]<- Surprise_results$p.value
  #  # test.data[i,5]<- testresults@optinfo$val
   print(i)
}
summary( avg_Anger_results)
 # test.data_bySurprise1<- test.data_bySurprise
 test.data_by_avg_Anger$p_holm<- p.adjust(test.data_by_avg_Anger$p, length(test.data_by_avg_Anger$p), method = "holm")
 
 test.data_by_avg_Anger$p_bonf<- p.adjust(test.data_by_avg_Anger$p, length(test.data_by_avg_Anger$p), 
                                          method ="bonf")
  View(test.data_by_avg_Anger)
# now sum adjancet timebins
  # testresults@optinfo$conv$opt$
  
  
  
    test.data_by_avg_Anger$cluster_counter
    
    View(test.data_by_avg_Anger)
  test.data_by_avg_Anger<-   test.data_by_avg_Anger %>%
  mutate(p_clustering =  if_else(is.na(cluster_counter),1,
                                 if_else(cluster_counter == 1, clust1_p,
                                         if_else(cluster_counter == 2, clust2_p,
                                                 # if_else(cluster_counter == 3, clust3_p,
                                                         NULL))))

  
  View(   test.data_by_avg_Anger)
  
test.data_by_avg_Anger<- test.data_by_avg_Anger %>%
  mutate(poten_clust = if_else(is.na(cluster_counter) == FALSE & cluster_counter > 0, 0,1))
  

plots_of$avg_Anger <- 
   test.data_by_avg_Anger %>%
  ggplot(aes(as.numeric(timebins), t))+
    geom_rect(aes(xmin = timebins, xmax = dplyr::lead(timebins), ymin =4.9 , ymax =5.2 , fill = p), 
            alpha = 0.8)+
  geom_rect(aes(xmin = timebins, xmax = dplyr::lead(timebins), ymin =5.7 , ymax =6 , fill = poten_clust),
            alpha = 0.8)+
  geom_rect(aes(xmin = timebins, xmax = dplyr::lead(timebins), ymin =5.3 , ymax =5.6 , fill = p_bonf), 
            alpha = 0.8)+

  geom_hline(yintercept = 2, linetype = 'dashed', size = 1.5, colour = 'red')+
     stat_summary(geom = 'line', size = 2)+
               theme_classic()+
  geom_hline(yintercept = -2, linetype = 'dashed', size = 1.5, colour = 'red')+
  stat_summary(geom = 'line', size = 2)+
               theme_classic()+
   geom_hline(yintercept = 0, linetype = 'dashed', size = 1.5, colour = 'gray')+
     stat_summary(geom = 'line', size = 2)+
               theme_classic()+
     # ylim(1,6)+
  scale_fill_viridis_c(breaks= c(0, .5, 1), limits = c(0,1))+
  # scale_colour_gradient2(limits = c(0,1))+
  # ggtitle("AVG face motion ~ Morph - Anger")+
  ggtitle("Anger")+
  xlab("Time (s)")+
ylab("t statistic")
   
plots_of$avg_Anger<- plots_of$avg_Anger+p$graphstyle+
  guides(fill = guide_colourbar(ticks = FALSE))+
  scale_y_continuous(breaks = c(-2, 2, 6), limits = c(-2,6))

plots_of$avg_Anger

# sf
  p$graphstyle <-  theme(#base plot theme
  # axis.line.y = element_blank(),
  # axis.line.x = element_blank(),
  strip.text.x = element_text(size = 11*(sf+.5),  colour = "black"),
  strip.text.y = element_text(size = 11*(sf+.5),  colour = "black"),
  panel.border = element_blank(),
  panel.grid.major = element_blank(),
  panel.grid.minor = element_blank(),
  panel.background = element_blank(),
  
  # plot title
  plot.title = element_text(size = 14*(sf+3),  colour = "black"),
  #panel.background = element_rect(fill="transparent"),
  #panel.border = element_rect(fill="transparent"),
  
  # LEGEND
  #legend.position = "top", 
  #legend.direction = "horizontal",
  #legend.key.size = unit(.5, "cm"),
  #legend.text = element_text(size = 10*sf+.3),
  legend.title = element_text(size = 10*(sf+1)),
  #legend.key.size = unit(.5, "cm"),
  legend.text = element_text(size = 10*(sf+.5)),
  #legend.title=element_blank(),
  #legend.text = element_blank(),
  text=element_text(size = 16, family = "sans"),
  axis.text.x = element_text(size = 14*(sf+1.5), family = "sans", colour = "black"),
  axis.text.y = element_text(size = 14*(sf+1.5), family = "sans", colour = "black"),
  #axis.ticks = element_blank(),
  # strip shades (reco rectagles)
  strip.background = element_blank(),
  #axis.text.y = element_text(size= 18, family = "Arial Narrow", colour="black"),
  axis.title.y=element_text(size = 16*(sf+1.5), margin=margin(0,5,0,0)),
  axis.title.x=element_text(size = 16*(sf+1.5), margin=margin(0,5,0,0)),
  legend.key = element_rect(colour = "transparent", fill="transparent"))


```

Anger boostrapping

```{r}
View(test.data_by_avg_Anger)

test.data_by_avg_Anger <- test.data_by_avg_Anger %>%
  ungroup()%>%
  mutate(cluster_log = if_else(test.data_by_avg_Anger$p< .05, TRUE, FALSE))%>%
  mutate(Direction = if_else(t > 0 & cluster_log == TRUE, "Positive", 
                             if_else(t < 0 & cluster_log == TRUE, "Negative", NULL)))%>% # flag direction that is
        # group_by(sim)%>%
        mutate(idx = !is.na(Direction))%>%
        mutate(cluster_counter  = as.numeric(replace(Direction, idx, rleid(rleid(Direction)[idx]))))%>%
      # create a cluster t sum by adjacency, remeber the up there we grouped 
      # cluster counter shuffle makes sure ajancent significant bisn are griuped together
      # direction - do we need thisDirection, cluster_shuffle_log 
      group_by(cluster_counter)%>%
      mutate(t_sum_dir = sum(t))%>%
      # ungroup()%>%
      mutate(t_sum_dir = if_else(cluster_log == TRUE, t_sum_dir, NULL))%>% #summ timebins into clusters statistics
        # create max cluster lavels, store the direction value of the cluster and the label of the direction
      # suppressWarnings
        # group_by(sim)%>%
      mutate(MaxCLust_label = if_else(abs(t_sum_dir) == max(abs(t_sum_dir), na.rm = TRUE),
                                      cluster_counter, NULL ))%>%
      # suppressWarnings
      mutate(MaxCLust_value = if_else(abs(t_sum_dir) == max(abs(t_sum_dir), na.rm = TRUE), 
                                      t_sum_dir, NULL ))%>%
      # suppressWarnings
      mutate(MaxCLust_direction = if_else(MaxCLust_value > 0, "Positive", "Negative"))
View(test.data_by_avg_Anger)
# negative estmate = morph has less actiation
        
library(data.table)
# create a counter for helpting with cluster by adjancecy

# regular corrections
# test.data_by_avg_Anger<- test.data_by_avg_Anger%>%
#   mutate(p_bonf = p.adjust(p, method = 'holm'))%>%
#   mutate(p_holm = p.adjust(p, method = "bonf"))


# go back to the data use to fit - db_of7_new[db_of7_new$timestamp == timebinout_avg[i],])
nrow(db_of7_new_avg_Anger)
db_of7_new_avg_Anger%>%
  # filter( Emotion == "Anger")%>%
  group_by(morph)%>%
  summarise(n = n())# 1280/2



i = 1

View(testtemp)

db_of7_new_avg_Anger%>%
  # filter(Emotion == "Anger")%>%
  group_by(video, morph)%>%
  summarise(time = mean(timebin, na.rm = TRUE))%>%
  group_by(morph)%>%
  summarise(n = n()) # collapsing time now we have 16 vidoe per videotype
              

timebin_shuff_Anger<- unique(db_of7_new_avg_Anger$timebin)

 # create a random arrangment of labels for oroginal and morpj

nsim = 1:1000 #no. of simullation
nbins  =1:40 # numbr of bins. aways check

#create an empty dataframe to store results of the simulation
# remeber to always define it before simulation

simulated_clusters_Anger<- data.frame(timebins= rep(NA, max(nsim)*max(nbins)), Estimate= rep(NA, max(nsim)*max(nbins)), t=rep(NA, max(nsim)*max(nbins)), p=rep(NA, max(nsim)*max(nbins)), cov= as.character(rep(NA,max(nsim)*max(nbins))), sim = rep(NA, max(nsim)*max(nbins)) )

View(simulated_clusters_Anger)

# timebin_random_ADFES<- unique(db_of7_new_avg_Anger$timebin)

# create random labels

i = 1 # remember to always rezero it
# b = 34

seed = 444

simulated_clusters_Anger$cov<- as.character( simulated_clusters_Anger$cov) # remeber to run

 i = 1
 # b = 1
 # s = 1
 
 View(db_of7_new_avg_Anger)
 
 db_of7_new_avg_Anger$VideoType_contrast<- if_else(db_of7_new_avg_Anger$morph == "Morph", -.5, .5) # morph == -.5, original .5

 i = 1

for (b in 1:length(nbins)) {
  for (s in 1:length(nsim)) {

    message(sprintf("$$$$$RUNING simulation %i & bin %i", nsim[s], nbins[b]))
    db_of7_new_avg_Anger$VideoType_contrast_sample<- sample((rep(c(-.5, .5), each =  640)), replace = FALSE) 
        #run the model on the current time bin and simulation sumber
        lmer_bin_random_Anger  <- lmer(log1p(face_action_AVG +.1) ~ VideoType_contrast_sample + 
                                   (1 |face_unique),
                      data = subset(db_of7_new_avg_Anger, db_of7_new_avg_Anger$timebin == timebin_shuff_Anger[b]))

        #store results from the somularion
            lmer_bin_random_summary_Anger<- summary(lmer_bin_random_Anger)
            simulated_clusters_Anger[i,1]<- timebin_shuff_Anger[b] #save the exact value of time bin
            simulated_clusters_Anger[i,2]<- lmer_bin_random_summary_Anger[["coefficients"]][2,1] # s
            simulated_clusters_Anger[i,3]<-lmer_bin_random_summary_Anger[["coefficients"]][2,4] # t statistic
            simulated_clusters_Anger[i,4]<-lmer_bin_random_summary_Anger[["coefficients"]][2,5] # p value
            simulated_clusters_Anger[i,6]<- nsim[s] #store simulation ount
            simulated_clusters_Anger[i,5] <-ifelse(length(lmer_bin_random_summary_Anger$optinfo$conv$lme4$message)
                                                   != 0,
                                               lmer_bin_random_summary_Anger$optinfo$conv$lme4$message, 'pass')

     i = i+1
  }
}



```

<!-- ADFES boostrap clustering -->

```{r}

 # Now do clustering of shuffled data, and s
     View(simulated_clusters_ADFES)
     table(simulated_clusters_ADFES$cov == 'pass') # check how many convrgence errors we have
#       4489/(4489+35511)
     
     simulated_clusters_ADFES%>%
       ggplot(aes(t))+
       geom_histogram()
     

      simulated_clusters_ADFES%>%
       ggplot(aes(timebins, t))+
         geom_line(aes(group = sim))+
        stat_summary(geom = 'line')

         
# [1] 0.112225
    simulated_clusters_ADFES$relgrad<- as.numeric(substr(simulated_clusters_ADFES$cov,43, 48)) #extract the convergence tol
    simulated_clusters_ADFES$relgrad_below<- if_else(simulated_clusters_ADFES$relgrad< .02, TRUE, FALSE)
     table(simulated_clusters_ADFES$relgrad_below)
     # 3/(61+3) ~ 4 %
     # (63)/(4489+35511) #so the total non convergence rate is .001 *100 == 0.1%
     
    ### Cluster again on the shuffled data###
     
     # & simulated_clusters$timebins == nbins[b] do we need ti grouo it by timebine
     # for each simulation, cluster timebins
      sum_cluster_sim_ADFES <- simulated_clusters_ADFES %>% 
        # filter( simulated_clusters$sim == nsim[s])%>% # pick the current simulation
        arrange(sim, timebins)%>%
        group_by(sim)%>%
        mutate(cluster_shuffle_log = if_else(p < .05, TRUE, FALSE))%>% # create a logical highlighticng signiiant
        # bins
        mutate(Direction = if_else(t > 0 & cluster_shuffle_log == TRUE, "Positive", 
                                  if_else(t < 0 & cluster_shuffle_log == TRUE, "Negative", NULL)))%>% # flag direction that is
        # filter(!is.na(Direction))%>% 
        #significant because later we will need to group by this
      #group_by(cluster_shuffle_log,Direction)%>%
      # below we are creating a counter that that counts only the significant bins, separatelly by whether their are positive or
        #negative to cinfirm if it works 
        group_by(sim)%>%
        mutate(idx = !is.na(Direction))%>%
        mutate(cluster_countershuffle  = as.numeric(replace(Direction, idx, rleid(rleid(Direction)[idx]))))%>%
      # create a cluster t sum by adjacency, remeber the up there we grouped 
      # cluster counter shuffle makes sure ajancent significant bisn are griuped together
      # direction - do we need thisDirection, cluster_shuffle_log 
      group_by(sim, cluster_countershuffle)%>%
      mutate(t_sum_shuffle_dir = sum(t))%>%
      # ungroup()%>%
      mutate(t_sum_shuffle_dir = if_else(cluster_shuffle_log == TRUE, t_sum_shuffle_dir, NULL))%>% #summ timebins into clusters statistics
        # create max cluster lavels, store the direction value of the cluster and the label of the direction
      # suppressWarnings
        group_by(sim)%>%
      mutate(MaxCLust_label = if_else(abs(t_sum_shuffle_dir) == max(abs(t_sum_shuffle_dir), na.rm = TRUE),
                                      cluster_countershuffle, NULL ))%>%
      # suppressWarnings
      mutate(MaxCLust_value = if_else(abs(t_sum_shuffle_dir) == max(abs(t_sum_shuffle_dir), na.rm = TRUE), 
                                      t_sum_shuffle_dir, NULL ))%>%
      # suppressWarnings
      mutate(MaxCLust_direction = if_else(MaxCLust_value > 0, "Positive", "Negative"))%>%
        
        #fill it
      fill(MaxCLust_label, .direction = "updown")%>%
      fill(MaxCLust_value, .direction = "updown")%>%
      fill(MaxCLust_direction, .direction = "updown")
      
      View(sum_cluster_sim_ADFES)
      # test sim 4 that had a probpem
      # sim4<- subset(sum_cluster_sim, sum_cluster_sim$sim == 4)
      # View(sim4)
    unique(sum_cluster_sim_ADFES$MaxCLust_value) 
    
     # a few warnings - invalid factor NA levels = 
 # ma NA = because there is no max that survived sigificance

    
    sum_cluster_sim_ADFES%>%
  mutate(MaxCLust_value = if_else(cluster_shuffle_log == TRUE, MaxCLust_value, t))%>%
  ggplot(aes(MaxCLust_value))+
  geom_histogram()
sum_cluster_sim_ADFES%>%
  mutate(MaxCLust_value = if_else(cluster_shuffle_log == TRUE, MaxCLust_value, NULL))%>%
  ggplot(aes(MaxCLust_value))+
  geom_histogram()
    
View(sum_cluster_sim_ADFES)




```




Joyy - Global average face
```{r}
db_of7_new_avg_Joy<- subset(db_of7_new, db_of7_new$Emotion == "Joy")

factor(db_of7_new_avg_Joy$morph)

test.data_by_avg_Joy<- data.frame(timebins= rep(NA, 40), Estimate= rep(NA, 40), t=rep(NA, 40), p=rep(NA, 40), cov= as.character(rep(NA,40)) )

timebin_avg_Joy<- unique(db_of7_new_avg_Joy$timebin)
# test.data$timebinout<- as.vector(timebinout) # add the curerent timebins to that vector

# empty list of test results
testresults_avg_Joy<- list()
# lmer


# currently we have 15 time bins
# the loop below does
# 1 - goes from element i ina  list of eleements 1 to the last time bind_cols
# 2- runs a lmer model regresing face distance to morph vs original, while controling for intercepts of dataset and intercept of unique faces
#3 - stores the result of the model
#4- store informatio on the bin tested, the coeficients, p values and t tests
# morph variance is almost zerp
# dtaset is highly correleted, so ignore


i = 2
for (i in 1:length(timebin_avg_Joy)) {
  # Surprise_results<- t.test(log1p(D1+.1) ~ morph,var.equal = FALSE, paired = FALSE, data = db_of7_new[db_of7_new$timestamp == timebinout[i],])
  avg_Joy_results<- lmer(log1p(D1+.1) ~ VideoType_contrast + (1 |face_unique) + (1 | Dataset),
                      data = db_of7_new_avg_Joy[db_of7_new_avg_Joy$timebin == timebin_avg_Joy[i],])

  # testresults<- lmer(log1p(D1+.1) ~ morph + (1|face_unique),
  #                     data = db_of7_new [db_of7_new$timebin == timebinout[i] & db_of7_new$Dataset !="ADFES",])
  avg_Joy_results_sum<- summary(avg_Joy_results)

   test.data_by_avg_Joy[i,1]<-timestamp_avg_Joy[i]
   test.data_by_avg_Joy[i,2]<- avg_Joy_results_sum[["coefficients"]][2,1]
   test.data_by_avg_Joy[i,3]<- avg_Joy_results_sum[["coefficients"]][2,4]
   test.data_by_avg_Joy[i,4]<- avg_Joy_results_sum[["coefficients"]][2,5]
  #
   
   
  #     test.data_bySurprise[i,1]<-timestamp_Surprise[i]
  # # test.data_bySurprise[i,2]<- Surprise_results_sum[["coefficients"]][2,1]
  #  test.data_bySurprise[i,3]<- Surprise_results$statistic
  #  test.data_bySurprise[i,4]<- Surprise_results$p.value
  #  # test.data[i,5]<- testresults@optinfo$val
   print(i)
}
summary( avg_Joy_results)
 # test.data_bySurprise1<- test.data_bySurprise
 test.data_by_avg_Joy$p_holm<- p.adjust(test.data_by_avg_Joy$p, length(test.data_by_avg_Joy$p), method = "holm")
 
 test.data_by_avg_Joy$p_bonf<- p.adjust(test.data_by_avg_Joy$p, length(test.data_by_avg_Joy$p), 
                                          method ="bonf")
  View(test.data_by_avg_Joy)
# now sum adjancet timebins
  # testresults@optinfo$conv$opt$
  
  
  
test.data_by_avg_Joy<- test.data_by_avg_Joy %>%
  mutate(poten_clust = if_else(is.na(cluster_counter) == FALSE & cluster_counter > 0, 0,1))
    

plots_of$avg_Joy <- 
   test.data_by_avg_Joy%>%
     ggplot(aes(as.numeric(timebins), t))+
     geom_rect(aes(xmin = timebins, xmax = dplyr::lead(timebins), ymin =4.9 , ymax =5.2 , fill = p), 
            alpha = 0.8)+
     geom_rect(aes(xmin = timebins, xmax = dplyr::lead(timebins), ymin =5.7 , ymax =6 , fill = poten_clust),
            alpha = 0.8)+
     geom_rect(aes(xmin = timebins, xmax = dplyr::lead(timebins), ymin =5.3 , ymax =5.6 , fill = p_bonf), 
            alpha = 0.8)+
     geom_hline(yintercept = 2, linetype = 'dashed', size = 1.5, colour = 'red')+
     stat_summary(geom = 'line', size = 2)+
               theme_classic()+
  geom_hline(yintercept = -2, linetype = 'dashed', size = 1.5, colour = 'red')+
     stat_summary(geom = 'line', size = 2)+
               theme_classic()+
  
   geom_hline(yintercept = 0, linetype = 'dashed', size = 1.5, colour = 'gray')+
     # ylim(1,6)+
   scale_fill_viridis_c(breaks= c(0, .5, 1), limits = c(0,1))+
      # scale_fill_viridis_c()+
     # scale_colour_gradient2(mid = "white", limits = c(0,1), midpoint = .5)+
  ggtitle("Happiness")+
  xlab("Time (s)")+
  ylab("t statistic")
   
plots_of$avg_Joy

plots_of$avg_Joy<- plots_of$avg_Joy+p$graphstyle+
  guides(fill = guide_colourbar(ticks = FALSE))+
  scale_y_continuous(breaks = c(-2, 2, 6), limits = c(-2,6))
  # theme(
    # axis.title.x = element_blank(),
        axis.title.y = element_blank(),
        axis.text.x = element_blank(),
        axis.text.y = element_blank())

plots_of$avg_Joy




```

Joy Global - boostrap

```{r}
View(test.data_by_avg_Joy)

test.data_by_avg_Joy <- test.data_by_avg_Joy %>%
  ungroup()%>%
  mutate(cluster_log = if_else(test.data_by_avg_Joy$p< .05, TRUE, FALSE))%>%
  mutate(Direction = if_else(t > 0 & cluster_log == TRUE, "Positive", 
                             if_else(t < 0 & cluster_log == TRUE, "Negative", NULL)))%>% # flag direction that is
        # group_by(sim)%>%
        mutate(idx = !is.na(Direction))%>%
        mutate(cluster_counter  = as.numeric(replace(Direction, idx, rleid(rleid(Direction)[idx]))))%>%
      # create a cluster t sum by adjacency, remeber the up there we grouped 
      # cluster counter shuffle makes sure ajancent significant bisn are griuped together
      # direction - do we need thisDirection, cluster_shuffle_log 
      group_by(cluster_counter)%>%
      mutate(t_sum_dir = sum(t))%>%
      # ungroup()%>%
      mutate(t_sum_dir = if_else(cluster_log == TRUE, t_sum_dir, NULL))%>% #summ timebins into clusters statistics
        # create max cluster lavels, store the direction value of the cluster and the label of the direction
      # suppressWarnings
        # group_by(sim)%>%
      mutate(MaxCLust_label = if_else(abs(t_sum_dir) == max(abs(t_sum_dir), na.rm = TRUE),
                                      cluster_counter, NULL ))%>%
      # suppressWarnings
      mutate(MaxCLust_value = if_else(abs(t_sum_dir) == max(abs(t_sum_dir), na.rm = TRUE), 
                                      t_sum_dir, NULL ))%>%
      # suppressWarnings
      mutate(MaxCLust_direction = if_else(MaxCLust_value > 0, "Positive", "Negative"))
View(test.data_by_avg_Joy)
# negative estmate = morph has less actiation
        
library(data.table)
# create a counter for helpting with cluster by adjancecy

# regular corrections
# test.data_by_avg_Joy<- test.data_by_avg_Joy%>%
#   mutate(p_bonf = p.adjust(p, method = 'holm'))%>%
#   mutate(p_holm = p.adjust(p, method = "bonf"))


# go back to the data use to fit - db_of7_new[db_of7_new$timestamp == timebinout_avg[i],])
nrow(db_of7_new_avg_Joy)
db_of7_new_avg_Joy%>%
  # filter( Emotion == "Joy")%>%
  group_by(morph)%>%
  summarise(n = n())# 1280/2



i = 1

View(testtemp)

db_of7_new_avg_Joy%>%
  # filter(Emotion == "Joy")%>%
  group_by(video, morph)%>%
  summarise(time = mean(timebin, na.rm = TRUE))%>%
  group_by(morph)%>%
  summarise(n = n()) # collapsing time now we have 16 vidoe per videotype
              

timebin_shuff_Joy<- unique(db_of7_new_avg_Joy$timebin)

 # create a random arrangment of labels for oroginal and morpj

nsim = 1:1000 #no. of simullation
nbins  =1:40 # numbr of bins. aways check

#create an empty dataframe to store results of the simulation
# remeber to always define it before simulation

simulated_clusters_Joy<- data.frame(timebins= rep(NA, max(nsim)*max(nbins)), Estimate= rep(NA, max(nsim)*max(nbins)), t=rep(NA, max(nsim)*max(nbins)), p=rep(NA, max(nsim)*max(nbins)), cov= as.character(rep(NA,max(nsim)*max(nbins))), sim = rep(NA, max(nsim)*max(nbins)) )

View(simulated_clusters_Joy)

# timebin_random_ADFES<- unique(db_of7_new_avg_Joy$timebin)

# create random labels

i = 1 # remember to always rezero it
# b = 34

seed = 444

simulated_clusters_Joy$cov<- as.character( simulated_clusters_Joy$cov) # remeber to run

 i = 1
 # b = 1
 # s = 1
 
 View(db_of7_new_avg_Joy)
 
 db_of7_new_avg_Joy$VideoType_contrast<- if_else(db_of7_new_avg_Joy$morph == "Morph", -.5, .5) # morph == -.5, original .5

 i = 1

for (b in 1:length(nbins)) {
  for (s in 1:length(nsim)) {

    message(sprintf("$$$$$RUNING simulation %i & bin %i", nsim[s], nbins[b]))
    db_of7_new_avg_Joy$VideoType_contrast_sample<- sample((rep(c(-.5, .5), each =  640)), replace = FALSE) 
        #run the model on the current time bin and simulation sumber
        lmer_bin_random_Joy  <- lmer(log1p(face_action_AVG +.1) ~ VideoType_contrast_sample + 
                                   (1 |face_unique),
                      data = subset(db_of7_new_avg_Joy, db_of7_new_avg_Joy$timebin == timebin_shuff_Joy[b]))

        #store results from the somularion
            lmer_bin_random_summary_Joy<- summary(lmer_bin_random_Joy)
            simulated_clusters_Joy[i,1]<- timebin_shuff_Joy[b] #save the exact value of time bin
            simulated_clusters_Joy[i,2]<- lmer_bin_random_summary_Joy[["coefficients"]][2,1] # s
            simulated_clusters_Joy[i,3]<-lmer_bin_random_summary_Joy[["coefficients"]][2,4] # t statistic
            simulated_clusters_Joy[i,4]<-lmer_bin_random_summary_Joy[["coefficients"]][2,5] # p value
            simulated_clusters_Joy[i,6]<- nsim[s] #store simulation ount
            simulated_clusters_Joy[i,5] <-ifelse(length(lmer_bin_random_summary_Joy$optinfo$conv$lme4$message)
                                                   != 0,
                                               lmer_bin_random_summary_Joy$optinfo$conv$lme4$message, 'pass')

     i = i+1
  }
}




```



Fear
```{r}
# db_of7_new$Emotion
db_of7_new_avg_Fear<- subset(db_of7_new, db_of7_new$Emotion == "Fear")



test.data_by_avg_Fear<- data.frame(timebins= rep(NA, 40), Estimate= rep(NA, 40), t=rep(NA, 40), p=rep(NA, 40), cov= as.character(rep(NA,40)) )

timebin_avg_Fear<- unique(db_of7_new_avg_Fear$timebin)
# test.data$timebinout<- as.vector(timebinout) # add the curerent timebins to that vector

# empty list of test results
testresults_avg_Fear<- list()
# lmer


# currently we have 15 time bins
# the loop below does
# 1 - goes from element i ina  list of eleements 1 to the last time bind_cols
# 2- runs a lmer model regresing face distance to morph vs original, while controling for intercepts of dataset and intercept of unique faces
#3 - stores the result of the model
#4- store informatio on the bin tested, the coeficients, p values and t tests
# morph variance is almost zerp
# dtaset is highly correleted, so ignore


i = 1
for (i in 1:length(timestamp_avg_Fear)) {
  # Surprise_results<- t.test(log1p(D1+.1) ~ morph,var.equal = FALSE, paired = FALSE, data = db_of7_new[db_of7_new$timestamp == timebinout[i],])
  avg_Fear_results<- lmer(log1p(D1+.1) ~ VideoType_contrast + (1 |face_unique) + (1 | Dataset),
                      data = db_of7_new_avg_Fear[db_of7_new_avg_Fear$timebin == timebin_avg_Fear[i],])

  # testresults<- lmer(log1p(D1+.1) ~ morph + (1|face_unique),
  #                     data = db_of7_new [db_of7_new$timebin == timebinout[i] & db_of7_new$Dataset !="ADFES",])
  avg_Fear_results_sum<- summary(avg_Fear_results)

   test.data_by_avg_Fear[i,1]<-timebin_avg_Fear[i]
   test.data_by_avg_Fear[i,2]<- avg_Fear_results_sum[["coefficients"]][2,1]
   test.data_by_avg_Fear[i,3]<- avg_Fear_results_sum[["coefficients"]][2,4]
   test.data_by_avg_Fear[i,4]<- avg_Fear_results_sum[["coefficients"]][2,5]
  #
   
   
  #     test.data_bySurprise[i,1]<-timestamp_Surprise[i]
  # # test.data_bySurprise[i,2]<- Surprise_results_sum[["coefficients"]][2,1]
  #  test.data_bySurprise[i,3]<- Surprise_results$statistic
  #  test.data_bySurprise[i,4]<- Surprise_results$p.value
  #  # test.data[i,5]<- testresults@optinfo$val
   print(i)
}
summary( avg_Fear_results)
 # test.data_bySurprise1<- test.data_bySurprise
 test.data_by_avg_Fear$p_holm<- p.adjust(test.data_by_avg_Fear$p, length(test.data_by_avg_Fear$p), method = "holm")
 
 test.data_by_avg_Fear$p_bonf<- p.adjust(test.data_by_avg_Fear$p, length(test.data_by_avg_Fear$p), 
                                          method ="bonf")
  View(test.data_by_avg_Fear)
# now sum adjancet timebins
  # testresults@optinfo$conv$opt$
  
  View(test.data_by_avg_Fear)
  
test.data_by_avg_Fear<- test.data_by_avg_Fear %>%
  mutate(poten_clust = if_else(is.na(cluster_counter) == FALSE & cluster_counter > 0, 0,1))

plots_of$avg_Fear <- 
   test.data_by_avg_Fear %>%
     ggplot(aes(as.numeric(timebins), t))+
  geom_rect(aes(xmin = timebins, xmax = dplyr::lead(timebins), ymin =4.9 , ymax =5.2 , fill = p), 
            alpha = 0.8)+
     geom_rect(aes(xmin = timebins, xmax = dplyr::lead(timebins), ymin =5.7 , ymax =6 , fill = poten_clust),
            alpha = 0.8)+
     geom_rect(aes(xmin = timebins, xmax = dplyr::lead(timebins), ymin =5.3 , ymax =5.6 , fill = p_bonf), 
            alpha = 0.8)+
   
     geom_hline(yintercept = 2, linetype = 'dashed', size = 1.5, colour = 'red')+
     stat_summary(geom = 'line', size = 2)+
               theme_classic()+
  geom_hline(yintercept = -2, linetype = 'dashed', size = 1.5, colour = 'red')+
     stat_summary(geom = 'line', size = 2)+
               theme_classic()+
  
   geom_hline(yintercept = 0, linetype = 'dashed', size = 1.5, colour = 'gray')+
     stat_summary(geom = 'line', size = 2)+
               theme_classic()+
     # ylim(1,6)+
      scale_fill_viridis_c()+
  scale_fill_viridis_c(breaks= c(0, .5, 1), limits = c(0,1))+
      # scale_fill_viridis_c()+
     # scale_colour_gradient2(mid = "white", limits = c(0,1), midpoint = .5)+
  ggtitle("Fear")+
  xlab("Time (s)")+
  ylab("t statistic")
   
plots_of$avg_Fear 

plots_of$avg_Fear <- plots_of$avg_Fear +p$graphstyle+
  guides(fill = guide_colourbar(ticks = FALSE))+
  scale_y_continuous(breaks = c(-2, 2, 6), limits = c(-2,6))

   
plots_of$avg_Fear



```

Fear Boostrap Global
```{r}
View(test.data_by_avg_Fear)

test.data_by_avg_Fear <- test.data_by_avg_Fear %>%
  ungroup()%>%
  mutate(cluster_log = if_else(test.data_by_avg_Fear$p< .05, TRUE, FALSE))%>%
  mutate(Direction = if_else(t > 0 & cluster_log == TRUE, "Positive", 
                             if_else(t < 0 & cluster_log == TRUE, "Negative", NULL)))%>% # flag direction that is
        # group_by(sim)%>%
        mutate(idx = !is.na(Direction))%>%
        mutate(cluster_counter  = as.numeric(replace(Direction, idx, rleid(rleid(Direction)[idx]))))%>%
      # create a cluster t sum by adjacency, remeber the up there we grouped 
      # cluster counter shuffle makes sure ajancent significant bisn are griuped together
      # direction - do we need thisDirection, cluster_shuffle_log 
      group_by(cluster_counter)%>%
      mutate(t_sum_dir = sum(t))%>%
      # ungroup()%>%
      mutate(t_sum_dir = if_else(cluster_log == TRUE, t_sum_dir, NULL))%>% #summ timebins into clusters statistics
        # create max cluster lavels, store the direction value of the cluster and the label of the direction
      # suppressWarnings
        # group_by(sim)%>%
      mutate(MaxCLust_label = if_else(abs(t_sum_dir) == max(abs(t_sum_dir), na.rm = TRUE),
                                      cluster_counter, NULL ))%>%
      # suppressWarnings
      mutate(MaxCLust_value = if_else(abs(t_sum_dir) == max(abs(t_sum_dir), na.rm = TRUE), 
                                      t_sum_dir, NULL ))%>%
      # suppressWarnings
      mutate(MaxCLust_direction = if_else(MaxCLust_value > 0, "Positive", "Negative"))
View(test.data_by_avg_Fear)
# negative estmate = morph has less actiation
        
library(data.table)
# create a counter for helpting with cluster by adjancecy

# regular corrections
# test.data_by_avg_Fear<- test.data_by_avg_Fear%>%
#   mutate(p_bonf = p.adjust(p, method = 'holm'))%>%
#   mutate(p_holm = p.adjust(p, method = "bonf"))


# go back to the data use to fit - db_of7_new[db_of7_new$timestamp == timebinout_avg[i],])
nrow(db_of7_new_avg_Fear)
db_of7_new_avg_Fear%>%
  # filter( Emotion == "Fear")%>%
  group_by(morph)%>%
  summarise(n = n())# 1280/2



i = 1

View(testtemp)

db_of7_new_avg_Fear%>%
  # filter(Emotion == "Fear")%>%
  group_by(video, morph)%>%
  summarise(time = mean(timebin, na.rm = TRUE))%>%
  group_by(morph)%>%
  summarise(n = n()) # collapsing time now we have 16 vidoe per videotype
              

timebin_shuff_Fear<- unique(db_of7_new_avg_Fear$timebin)

 # create a random arrangment of labels for oroginal and morpj

nsim = 1:1000 #no. of simullation
nbins  =1:40 # numbr of bins. aways check

#create an empty dataframe to store results of the simulation
# remeber to always define it before simulation

simulated_clusters_Fear<- data.frame(timebins= rep(NA, max(nsim)*max(nbins)), Estimate= rep(NA, max(nsim)*max(nbins)), t=rep(NA, max(nsim)*max(nbins)), p=rep(NA, max(nsim)*max(nbins)), cov= as.character(rep(NA,max(nsim)*max(nbins))), sim = rep(NA, max(nsim)*max(nbins)) )

View(simulated_clusters_Fear)

# timebin_random_ADFES<- unique(db_of7_new_avg_Fear$timebin)

# create random labels

i = 1 # remember to always rezero it
# b = 34

seed = 444

simulated_clusters_Fear$cov<- as.character( simulated_clusters_Fear$cov) # remeber to run

 i = 1
 # b = 1
 # s = 1
 
 View(db_of7_new_avg_Fear)
 
 db_of7_new_avg_Fear$VideoType_contrast<- if_else(db_of7_new_avg_Fear$morph == "Morph", -.5, .5) # morph == -.5, original .5

 i = 1

for (b in 1:length(nbins)) {
  for (s in 1:length(nsim)) {

    message(sprintf("$$$$$RUNING simulation %i & bin %i", nsim[s], nbins[b]))
    db_of7_new_avg_Fear$VideoType_contrast_sample<- sample((rep(c(-.5, .5), each =  640)), replace = FALSE) 
        #run the model on the current time bin and simulation sumber
        lmer_bin_random_Fear  <- lmer(log1p(face_action_AVG +.1) ~ VideoType_contrast_sample + 
                                   (1 |face_unique),
                      data = subset(db_of7_new_avg_Fear, db_of7_new_avg_Fear$timebin == timebin_shuff_Fear[b]))

        #store results from the somularion
            lmer_bin_random_summary_Fear<- summary(lmer_bin_random_Fear)
            simulated_clusters_Fear[i,1]<- timebin_shuff_Fear[b] #save the exact value of time bin
            simulated_clusters_Fear[i,2]<- lmer_bin_random_summary_Fear[["coefficients"]][2,1] # s
            simulated_clusters_Fear[i,3]<-lmer_bin_random_summary_Fear[["coefficients"]][2,4] # t statistic
            simulated_clusters_Fear[i,4]<-lmer_bin_random_summary_Fear[["coefficients"]][2,5] # p value
            simulated_clusters_Fear[i,6]<- nsim[s] #store simulation ount
            simulated_clusters_Fear[i,5] <-ifelse(length(lmer_bin_random_summary_Fear$optinfo$conv$lme4$message)
                                                   != 0,
                                               lmer_bin_random_summary_Fear$optinfo$conv$lme4$message, 'pass')

     i = i+1
  }
}



 
# calculation of propabilities
# p-value for the cluster
# p value is calculated by taking the number of times the sum t statistic was greater than the observed one

# View(sum_cluster_sim_ADFES)
# View( test.data_avgface_ADFES)
# sum_cluster_sim_ADFES$timebins1<- substr((sum_cluster_sim_ADFES$timebins+.06),1,3)
# test.data_avgface_ADFES$timebins1<-substr( test.data_avgface_ADFES$timebins,1,3)

 View(simulated_clusters_Fear)
 View(sum_cluster_sim_ADFES)
simulattion_vs_data_ADFES<- left_join(sum_cluster_sim_ADFES, test.data_avgface_ADFES, by =
                                        c('timebins1'))
View(simulattion_vs_data_ADFES)


simulattion_vs_data_ADFES<- simulattion_vs_data_ADFES%>%
    ungroup()%>%
      # group_by(sim,Direction.y) %>%
  fill(MaxCLust_value.y, .direction = "down")%>%
  fill(MaxCLust_direction.y, .direction = "down")%>%
  # fill(MaxCLust_value.y, .direction = "down")%>%
  mutate(MAX_clust_count= if_else(is.na(MaxCLust_value.x) == TRUE,0, 
                                  if_else(abs(!is.na(MaxCLust_value.x))> abs(!is.na(MaxCLust_value.y)), 1, 0)))


# I think we need to take the clusters to columns (SPREAD)
# How many clusters did we have in the data
unique(simulattion_vs_data_ADFES$cluster_counter)
simulattion_vs_data_ADFES  <- simulattion_vs_data_ADFES %>%
  # group_by(cluster_counter)%>%
  mutate(cluster1_tsum = if_else(cluster_counter == 1, t_sum_dir, NULL))%>%
  mutate(cluster1_direction = if_else(cluster_counter == 1, MaxCLust_direction.y, NULL))%>%
  mutate(cluster2_tsum = if_else(cluster_counter == 2, t_sum_dir, NULL))%>%
  mutate(cluster2_direction = if_else(cluster_counter == 2, MaxCLust_direction.y, NULL))%>%
  mutate(cluster3_tsum = if_else(cluster_counter == 3, t_sum_dir, NULL))%>%
  mutate(cluster3_direction = if_else(cluster_counter == 3,MaxCLust_direction.y, NULL))%>%
  fill(cluster1_tsum, .direction = 'updown')%>%
  fill(cluster2_tsum, .direction = 'updown')%>%
  fill(cluster3_tsum, .direction = 'updown')%>%
  fill(cluster1_direction , .direction = 'updown')%>%
  fill(cluster2_direction , .direction = 'updown')%>%
  fill(cluster3_direction , .direction = 'updown')

View(simulattion_vs_data_ADFES)


unique(simulattion_vs_data$MAX_clust_count)
View(simulattion_vs_data_ADFES)
#  i think we need to tae the t value when the simulations are not significant
table(is.na(simulattion_vs_data_ADFES$t_sum_shuffle_dir))
 simulattion_vs_data_ADFES <-  simulattion_vs_data_ADFES %>%
   
  mutate(Max_clust_value_and_ns_t = if_else(is.na(t_sum_shuffle_dir), t.x, t_sum_shuffle_dir))%>%
  mutate(Max_clust_value_and_ns_t_jelka = t_sum_shuffle_dir)%>%
  mutate(Clust1_sim_biggerthan_data = if_else(abs(Max_clust_value_and_ns_t)> abs(cluster1_tsum), 1,0))%>%
  mutate(Clust2_sim_biggerthan_data = if_else(abs(Max_clust_value_and_ns_t)> abs(cluster2_tsum), 1,0))%>%
  # mutate(Clust3_sim_biggerthan_data = if_else(abs(Max_clust_value_and_ns_t)> abs(cluster3_tsum), 1,0))%>%
   
  mutate(Clust1_sim_biggerthan_data1 = if_else(abs(Max_clust_value_and_ns_t_jelka)> abs(cluster1_tsum), 1,0))%>%
  mutate(Clust2_sim_biggerthan_data2 = if_else(abs(Max_clust_value_and_ns_t_jelka)> abs(cluster2_tsum), 1,0))%>%
  # mutate(Clust3_sim_biggerthan_data3 = if_else(abs(Max_clust_value_and_ns_t_jelka)> abs(cluster3_tsum), 1,0))%>%

  # mutate(Clust2_sim_biggerthan_data = if_else(abs(Max_clust_value_and_ns_t) > abs(cluster2_tsum), 1,0))%>%
  mutate(clust1_p =  sum(Clust1_sim_biggerthan_data)/n())%>%
  mutate(clust2_p =  sum(Clust2_sim_biggerthan_data)/n())%>%
  # mutate(clust3_p =  sum(Clust3_sim_biggerthan_data)/n())%>%
   
  mutate(clust1_p_jelka =  sum(Clust1_sim_biggerthan_data)/2001)%>%
  mutate(clust2_p_jelka =  sum(Clust2_sim_biggerthan_data)/2001)
  # mutate(clust3_p_jelka =  sum(Clust3_sim_biggerthan_data)/2001)
 # get p values
p_values_ADFES<- 
  simulattion_vs_data_ADFES %>%
  # subset(simulattion_vs_data_ADFES, is.na(as.factor(simulattion_vs_data_ADFES$cluster_counter)))%%
  group_by(cluster_counter)%>%
  summarise_at(c('clust1_p', 'clust2_p', 'clust3_p', 'clust1_p_jelka', 'clust2_p_jelka', 'clust3_p_jelka'), mean, na.rm = TRUE)

p_values_ADFES
test.data_avgface_ADFES<-left_join(test.data_avgface_ADFES, p_values_ADFES)


```



Disgust
```{r}
# db_of7_new$Emotion
db_of7_new_avg_Disgust<- subset(db_of7_new, db_of7_new$Emotion == "Disgust")



test.data_by_avg_Disgust<- data.frame(timebins= rep(NA, 40), Estimate= rep(NA, 40), t=rep(NA, 40), p=rep(NA, 40), cov= as.character(rep(NA,40)) )

timebin_avg_Disgust<- unique(db_of7_new_avg_Disgust$timebin)
# test.data$timebinout<- as.vector(timebinout) # add the curerent timebins to that vector

# empty list of test results
testresults_avg_Disgust<- list()
# lmer


# currently we have 15 time bins
# the loop below does
# 1 - goes from element i ina  list of eleements 1 to the last time bind_cols
# 2- runs a lmer model regresing face distance to morph vs original, while controling for intercepts of dataset and intercept of unique faces
#3 - stores the result of the model
#4- store informatio on the bin tested, the coeficients, p values and t tests
# morph variance is almost zerp
# dtaset is highly correleted, so ignore


i = 2
for (i in 1:length(timestamp_avg_Disgust)) {
  # Surprise_results<- t.test(log1p(D1+.1) ~ morph,var.equal = FALSE, paired = FALSE, data = db_of7_new[db_of7_new$timestamp == timebinout[i],])
  avg_Disgust_results<- lmer(log1p(D1+.1) ~ VideoType_contrast + (1 |face_unique) + (1 | Dataset),
                      data = db_of7_new_avg_Disgust[db_of7_new_avg_Disgust$timebin == timebin_avg_Disgust[i],])

  # testresults<- lmer(log1p(D1+.1) ~ morph + (1|face_unique),
  #                     data = db_of7_new [db_of7_new$timebin == timebinout[i] & db_of7_new$Dataset !="ADFES",])
  avg_Disgust_results_sum<- summary(avg_Disgust_results)

   test.data_by_avg_Disgust[i,1]<-timebin_avg_Disgust[i]
   test.data_by_avg_Disgust[i,2]<- avg_Disgust_results_sum[["coefficients"]][2,1]
   test.data_by_avg_Disgust[i,3]<- avg_Disgust_results_sum[["coefficients"]][2,4]
   test.data_by_avg_Disgust[i,4]<- avg_Disgust_results_sum[["coefficients"]][2,5]
  #
   
   
  #     test.data_bySurprise[i,1]<-timestamp_Surprise[i]
  # # test.data_bySurprise[i,2]<- Surprise_results_sum[["coefficients"]][2,1]
  #  test.data_bySurprise[i,3]<- Surprise_results$statistic
  #  test.data_bySurprise[i,4]<- Surprise_results$p.value
  #  # test.data[i,5]<- testresults@optinfo$val
   print(i)
}
summary( avg_Disgust_results)
 # test.data_bySurprise1<- test.data_bySurprise
 test.data_by_avg_Disgust$p_holm<- p.adjust(test.data_by_avg_Disgust$p, length(test.data_by_avg_Disgust$p), method = "holm")
 
 test.data_by_avg_Disgust$p_bonf<- p.adjust(test.data_by_avg_Disgust$p, length(test.data_by_avg_Disgust$p), 
                                          method ="bonf")
  View(test.data_by_avg_Disgust)
# now sum adjancet timebins
  # testresults@optinfo$conv$opt$
test.data_by_avg_Disgust<- test.data_by_avg_Disgust%>%
  
  mutate(potent_clust = if_else(is.na(cluster_counter) == FALSE & cluster_counter>0, 0, 1))
  # p_clust<- test.data_by_avg_Disgust$
  
  View( test.data_by_avg_Disgust)
  
  

  
plots_of$avg_Disgust <- 
   test.data_by_avg_Disgust%>%
     ggplot(aes(as.numeric(timebins), t))+
     geom_rect(aes(xmin = timebins, xmax = dplyr::lead(timebins), ymin =4.9 , ymax =5.2 , fill = p), 
            alpha = 0.8)+
     geom_hline(yintercept = 2, linetype = 'dashed', size = 1.5, colour = 'red')+
     geom_rect(aes(xmin = timebins, xmax = dplyr::lead(timebins), ymin =5.7 , ymax =6 , fill = potent_clust),
            alpha = 0.8)+
     geom_rect(aes(xmin = timebins, xmax = dplyr::lead(timebins), ymin =5.3 , ymax =5.6 , fill = p_bonf), 
            alpha = 0.8)+

     geom_hline(yintercept = 2, linetype = 'dashed', size = 1.5, colour = 'red') +
     stat_summary(geom = 'line', size = 2)+
               theme_classic()+
  geom_hline(yintercept = -2, linetype = 'dashed', size = 1.5, colour = 'red')+
     stat_summary(geom = 'line', size = 2)+
               theme_classic()+
   geom_hline(yintercept = 0, linetype = 'dashed', size = 1.5, colour = 'gray')+
     stat_summary(geom = 'line', size = 2)+
               theme_classic()+
     # ylim(1,6)+
      scale_fill_viridis_c()+
  scale_fill_viridis_c(breaks= c(0, .5, 1), limits = c(0,1))+
      # scale_fill_viridis_c()+
     # scale_colour_gradient2(mid = "white", limits = c(0,1), midpoint = .5)+
  ggtitle("Disgust")+
  xlab("Time (s)")+
  ylab("t statistic")
   
plots_of$avg_Disgust

plots_of$avg_Disgust <- plots_of$avg_Disgust +p$graphstyle+
  guides(fill = guide_colourbar(ticks = FALSE))+
  scale_y_continuous(breaks = c(-2, 2, 6), limits = c(-2,6))
   
plots_of$avg_Disgust




```


Boostrap Disgust



```{r}
View(test.data_by_avg_Disgust)

test.data_by_avg_Disgust <- test.data_by_avg_Disgust %>%
  ungroup()%>%
  mutate(cluster_log = if_else(test.data_by_avg_Disgust$p< .05, TRUE, FALSE))%>%
  mutate(Direction = if_else(t > 0 & cluster_log == TRUE, "Positive", 
                             if_else(t < 0 & cluster_log == TRUE, "Negative", NULL)))%>% # flag direction that is
        # group_by(sim)%>%
        mutate(idx = !is.na(Direction))%>%
        mutate(cluster_counter  = as.numeric(replace(Direction, idx, rleid(rleid(Direction)[idx]))))%>%
      # create a cluster t sum by adjacency, remeber the up there we grouped 
      # cluster counter shuffle makes sure ajancent significant bisn are griuped together
      # direction - do we need thisDirection, cluster_shuffle_log 
      group_by(cluster_counter)%>%
      mutate(t_sum_dir = sum(t))%>%
      # ungroup()%>%
      mutate(t_sum_dir = if_else(cluster_log == TRUE, t_sum_dir, NULL))%>% #summ timebins into clusters statistics
        # create max cluster lavels, store the direction value of the cluster and the label of the direction
      # suppressWarnings
        # group_by(sim)%>%
      mutate(MaxCLust_label = if_else(abs(t_sum_dir) == max(abs(t_sum_dir), na.rm = TRUE),
                                      cluster_counter, NULL ))%>%
      # suppressWarnings
      mutate(MaxCLust_value = if_else(abs(t_sum_dir) == max(abs(t_sum_dir), na.rm = TRUE), 
                                      t_sum_dir, NULL ))%>%
      # suppressWarnings
      mutate(MaxCLust_direction = if_else(MaxCLust_value > 0, "Positive", "Negative"))
View(test.data_by_avg_Disgust)
# negative estmate = morph has less actiation
        
library(data.table)
# create a counter for helpting with cluster by adjancecy

# regular corrections
# test.data_by_avg_Disgust<- test.data_by_avg_Disgust%>%
#   mutate(p_bonf = p.adjust(p, method = 'holm'))%>%
#   mutate(p_holm = p.adjust(p, method = "bonf"))


# go back to the data use to fit - db_of7_new[db_of7_new$timestamp == timebinout_avg[i],])
nrow(db_of7_new_avg_Disgust)
db_of7_new_avg_Disgust%>%
  # filter( Emotion == "Disgust")%>%
  group_by(morph)%>%
  summarise(n = n())# 1280/2



i = 1

View(testtemp)

db_of7_new_avg_Disgust%>%
  # filter(Emotion == "Disgust")%>%
  group_by(video, morph)%>%
  summarise(time = mean(timebin, na.rm = TRUE))%>%
  group_by(morph)%>%
  summarise(n = n()) # collapsing time now we have 16 vidoe per videotype
              

timebin_shuff_Disgust<- unique(db_of7_new_avg_Disgust$timebin)

 # create a random arrangment of labels for oroginal and morpj

nsim = 1:1000 #no. of simullation
nbins  =1:40 # numbr of bins. aways check

#create an empty dataframe to store results of the simulation
# remeber to always define it before simulation

simulated_clusters_Disgust<- data.frame(timebins= rep(NA, max(nsim)*max(nbins)), Estimate= rep(NA, max(nsim)*max(nbins)), t=rep(NA, max(nsim)*max(nbins)), p=rep(NA, max(nsim)*max(nbins)), cov= as.character(rep(NA,max(nsim)*max(nbins))), sim = rep(NA, max(nsim)*max(nbins)) )

View(simulated_clusters_Disgust)

# timebin_random_ADFES<- unique(db_of7_new_avg_Disgust$timebin)

# create random labels

i = 1 # remember to always rezero it
# b = 34

seed = 444

simulated_clusters_Disgust$cov<- as.character( simulated_clusters_Disgust$cov) # remeber to run

 i = 1
 # b = 1
 # s = 1
 
 View(db_of7_new_avg_Disgust)
 
 db_of7_new_avg_Disgust$VideoType_contrast<- if_else(db_of7_new_avg_Disgust$morph == "Morph", -.5, .5) # morph == -.5, original .5

 i = 1

for (b in 1:length(nbins)) {
  for (s in 1:length(nsim)) {

    message(sprintf("$$$$$RUNING simulation %i & bin %i", nsim[s], nbins[b]))
    db_of7_new_avg_Disgust$VideoType_contrast_sample<- sample((rep(c(-.5, .5), each =  640)), replace = FALSE) 
        #run the model on the current time bin and simulation sumber
        lmer_bin_random_Disgust  <- lmer(log1p(face_action_AVG +.1) ~ VideoType_contrast_sample + 
                                   (1 |face_unique),
                      data = subset(db_of7_new_avg_Disgust, db_of7_new_avg_Disgust$timebin == timebin_shuff_Disgust[b]))

        #store results from the somularion
            lmer_bin_random_summary_Disgust<- summary(lmer_bin_random_Disgust)
            simulated_clusters_Disgust[i,1]<- timebin_shuff_Disgust[b] #save the exact value of time bin
            simulated_clusters_Disgust[i,2]<- lmer_bin_random_summary_Disgust[["coefficients"]][2,1] # s
            simulated_clusters_Disgust[i,3]<-lmer_bin_random_summary_Disgust[["coefficients"]][2,4] # t statistic
            simulated_clusters_Disgust[i,4]<-lmer_bin_random_summary_Disgust[["coefficients"]][2,5] # p value
            simulated_clusters_Disgust[i,6]<- nsim[s] #store simulation ount
            simulated_clusters_Disgust[i,5] <-ifelse(length(lmer_bin_random_summary_Disgust$optinfo$conv$lme4$message)
                                                   != 0,
                                               lmer_bin_random_summary_Disgust$optinfo$conv$lme4$message, 'pass')

     i = i+1
  }
}




```


Surprise
```{r}
# db_of7_new$Emotion
db_of7_new_avg_Surprise<- subset(db_of7_new, db_of7_new$Emotion == "Surprise")



test.data_by_avg_Surprise<- data.frame(timebins= rep(NA, 40), Estimate= rep(NA, 40), t=rep(NA, 40), p=rep(NA, 40), cov= as.character(rep(NA,40)) )

timebin_avg_Surprise<- unique(db_of7_new_avg_Surprise$timebin)
# test.data$timebinout<- as.vector(timebinout) # add the curerent timebins to that vector

# empty list of test results
testresults_avg_Surprise<- list()
# lmer


# currently we have 15 time bins
# the loop below does
# 1 - goes from element i ina  list of eleements 1 to the last time bind_cols
# 2- runs a lmer model regresing face distance to morph vs original, while controling for intercepts of dataset and intercept of unique faces
#3 - stores the result of the model
#4- store informatio on the bin tested, the coeficients, p values and t tests
# morph variance is almost zerp
# dtaset is highly correleted, so ignore


i = 2

for (i in 1:length(timebin_avg_Surprise)) {
  # Surprise_results<- t.test(log1p(D1+.1) ~ morph,var.equal = FALSE, paired = FALSE, data = db_of7_new[db_of7_new$timestamp == timebinout[i],])
  avg_Surprise_results<- lmer(log1p(D1+.1) ~ morph + (1 |face_unique) + (1 | Dataset),
                      data = db_of7_new_avg_Surprise[db_of7_new_avg_Surprise$timebin == timebin_avg_Surprise[i],])

  # testresults<- lmer(log1p(D1+.1) ~ morph + (1|face_unique),
  #                     data = db_of7_new [db_of7_new$timebin == timebinout[i] & db_of7_new$Dataset !="ADFES",])
  avg_Surprise_results_sum<- summary(avg_Surprise_results)

   test.data_by_avg_Surprise[i,1]<-timebin_avg_Surprise[i]
   test.data_by_avg_Surprise[i,2]<- avg_Surprise_results_sum[["coefficients"]][2,1]
   test.data_by_avg_Surprise[i,3]<- avg_Surprise_results_sum[["coefficients"]][2,4]
   test.data_by_avg_Surprise[i,4]<- avg_Surprise_results_sum[["coefficients"]][2,5]
  #
   
   
  #     test.data_bySurprise[i,1]<-timestamp_Surprise[i]
  # # test.data_bySurprise[i,2]<- Surprise_results_sum[["coefficients"]][2,1]
  #  test.data_bySurprise[i,3]<- Surprise_results$statistic
  #  test.data_bySurprise[i,4]<- Surprise_results$p.value
  #  # test.data[i,5]<- testresults@optinfo$val
   print(i)
}
summary( avg_Surprise_results)
 # test.data_bySurprise1<- test.data_bySurprise
 test.data_by_avg_Surprise$p_holm<- p.adjust(test.data_by_avg_Surprise$p, length(test.data_by_avg_Surprise$p), method = "holm")
 
 test.data_by_avg_Surprise$p_bonf<- p.adjust(test.data_by_avg_Surprise$p, length(test.data_by_avg_Surprise$p), 
                                          method ="bonf")
  View(test.data_by_avg_Surprise)
# now sum adjancet timebins
  # testresults@optinfo$conv$opt$
  
  test.data_by_avg_Surprise<- test.data_by_avg_Surprise %>%
  mutate(poten_clust = if_else(is.na(cluster_counter) == FALSE & cluster_counter > 0, 0,1))


plots_of$avg_Surprise <- 
   test.data_by_avg_Surprise%>%
     ggplot(aes(as.numeric(timebins), t))+
     geom_rect(aes(xmin = timebins, xmax = dplyr::lead(timebins), ymin =4.9 , ymax =5.2 , fill = p), 
            alpha = 0.8)+
     geom_rect(aes(xmin = timebins, xmax = dplyr::lead(timebins), ymin =5.7 , ymax =6 , fill = poten_clust),
            alpha = 0.8)+
     geom_rect(aes(xmin = timebins, xmax = dplyr::lead(timebins), ymin =5.3 , ymax =5.6 , fill = p_bonf), 
            alpha = 0.8)+
     geom_hline(yintercept = 2, linetype = 'dashed', size = 1.5, colour = 'red')+
     stat_summary(geom = 'line', size = 2)+
               theme_classic()+
  geom_hline(yintercept = -2, linetype = 'dashed', size = 1.5, colour = 'red')+
     stat_summary(geom = 'line', size = 2)+
               theme_classic()+
  geom_hline(yintercept = 0, linetype = 'dashed', size = 1.5, colour = 'gray')+
     stat_summary(geom = 'line', size = 2)+
               theme_classic()+
     # ylim(1,6)+
      # scale_fill_viridis_c()+
  # scale_colour_gradient2(mid = "white", limits = c(0,1), midpoint = .5)+
  scale_fill_viridis_c(breaks= c(0, .5, 1), limits = c(0,1))+
  ggtitle("Surprise")+
  xlab("Time (s)")+
  ylab("t statistic")
   
plots_of$avg_Surprise <- plots_of$avg_Surprise+ p$graphstyle+
  guides(fill = guide_colourbar(ticks = FALSE))+
  scale_y_continuous(breaks = c(-6, 0, 6), limits = c(-6,6))

plots_of$avg_Surprise
```

Suprise Boostrap


```{r}
View(test.data_by_avg_Surprise)

test.data_by_avg_Surprise <- test.data_by_avg_Surprise %>%
  ungroup()%>%
  mutate(cluster_log = if_else(test.data_by_avg_Surprise$p< .05, TRUE, FALSE))%>%
  mutate(Direction = if_else(t > 0 & cluster_log == TRUE, "Positive", 
                             if_else(t < 0 & cluster_log == TRUE, "Negative", NULL)))%>% # flag direction that is
        # group_by(sim)%>%
        mutate(idx = !is.na(Direction))%>%
        mutate(cluster_counter  = as.numeric(replace(Direction, idx, rleid(rleid(Direction)[idx]))))%>%
      # create a cluster t sum by adjacency, remeber the up there we grouped 
      # cluster counter shuffle makes sure ajancent significant bisn are griuped together
      # direction - do we need thisDirection, cluster_shuffle_log 
      group_by(cluster_counter)%>%
      mutate(t_sum_dir = sum(t))%>%
      # ungroup()%>%
      mutate(t_sum_dir = if_else(cluster_log == TRUE, t_sum_dir, NULL))%>% #summ timebins into clusters statistics
        # create max cluster lavels, store the direction value of the cluster and the label of the direction
      # suppressWarnings
        # group_by(sim)%>%
      mutate(MaxCLust_label = if_else(abs(t_sum_dir) == max(abs(t_sum_dir), na.rm = TRUE),
                                      cluster_counter, NULL ))%>%
      # suppressWarnings
      mutate(MaxCLust_value = if_else(abs(t_sum_dir) == max(abs(t_sum_dir), na.rm = TRUE), 
                                      t_sum_dir, NULL ))%>%
      # suppressWarnings
      mutate(MaxCLust_direction = if_else(MaxCLust_value > 0, "Positive", "Negative"))
View(test.data_by_avg_Surprise)
# negative estmate = morph has less actiation
        
library(data.table)
# create a counter for helpting with cluster by adjancecy

# regular corrections
# test.data_by_avg_Surprise<- test.data_by_avg_Surprise%>%
#   mutate(p_bonf = p.adjust(p, method = 'holm'))%>%
#   mutate(p_holm = p.adjust(p, method = "bonf"))


# go back to the data use to fit - db_of7_new[db_of7_new$timestamp == timebinout_avg[i],])
nrow(db_of7_new_avg_Surprise)
db_of7_new_avg_Surprise%>%
  # filter( Emotion == "Surprise")%>%
  group_by(morph)%>%
  summarise(n = n())# 1280/2



i = 1

View(testtemp)

db_of7_new_avg_Surprise%>%
  # filter(Emotion == "Surprise")%>%
  group_by(video, morph)%>%
  summarise(time = mean(timebin, na.rm = TRUE))%>%
  group_by(morph)%>%
  summarise(n = n()) # collapsing time now we have 16 vidoe per videotype
              

timebin_shuff_Surprise<- unique(db_of7_new_avg_Surprise$timebin)

 # create a random arrangment of labels for oroginal and morpj

nsim = 1:1000 #no. of simullation
nbins  =1:40 # numbr of bins. aways check

#create an empty dataframe to store results of the simulation
# remeber to always define it before simulation

simulated_clusters_Surprise<- data.frame(timebins= rep(NA, max(nsim)*max(nbins)), Estimate= rep(NA, max(nsim)*max(nbins)), t=rep(NA, max(nsim)*max(nbins)), p=rep(NA, max(nsim)*max(nbins)), cov= as.character(rep(NA,max(nsim)*max(nbins))), sim = rep(NA, max(nsim)*max(nbins)) )

View(simulated_clusters_Surprise)

# timebin_random_ADFES<- unique(db_of7_new_avg_Surprise$timebin)

# create random labels

i = 1 # remember to always rezero it
# b = 34

seed = 444

simulated_clusters_Surprise$cov<- as.character( simulated_clusters_Surprise$cov) # remeber to run

 i = 1
 # b = 1
 # s = 1
 
 View(db_of7_new_avg_Surprise)
 
 db_of7_new_avg_Surprise$VideoType_contrast<- if_else(db_of7_new_avg_Surprise$morph == "Morph", -.5, .5) # morph == -.5, original .5

 i = 1

for (b in 1:length(nbins)) {
  for (s in 1:length(nsim)) {

    message(sprintf("$$$$$RUNING simulation %i & bin %i", nsim[s], nbins[b]))
    db_of7_new_avg_Surprise$VideoType_contrast_sample<- sample((rep(c(-.5, .5), each =  640)), replace = FALSE) 
        #run the model on the current time bin and simulation sumber
        lmer_bin_random_Surprise  <- lmer(log1p(face_action_AVG +.1) ~ VideoType_contrast_sample + 
                                   (1 |face_unique),
                      data = subset(db_of7_new_avg_Surprise, db_of7_new_avg_Surprise$timebin == timebin_shuff_Surprise[b]))

        #store results from the somularion
            lmer_bin_random_summary_Surprise<- summary(lmer_bin_random_Surprise)
            simulated_clusters_Surprise[i,1]<- timebin_shuff_Surprise[b] #save the exact value of time bin
            simulated_clusters_Surprise[i,2]<- lmer_bin_random_summary_Surprise[["coefficients"]][2,1] # s
            simulated_clusters_Surprise[i,3]<-lmer_bin_random_summary_Surprise[["coefficients"]][2,4] # t statistic
            simulated_clusters_Surprise[i,4]<-lmer_bin_random_summary_Surprise[["coefficients"]][2,5] # p value
            simulated_clusters_Surprise[i,6]<- nsim[s] #store simulation ount
            simulated_clusters_Surprise[i,5] <-ifelse(length(lmer_bin_random_summary_Surprise$optinfo$conv$lme4$message)
                                                   != 0,
                                               lmer_bin_random_summary_Surprise$optinfo$conv$lme4$message, 'pass')

     i = i+1
  }
}




```



Sadness

```{r}
# db_of7_new$Emotion
db_of7_new_avg_Sadness<- subset(db_of7_new, db_of7_new$Emotion == "Sadness")



test.data_by_avg_Sadness<- data.frame(timebins= rep(NA, 40), Estimate= rep(NA, 40), t=rep(NA, 40), p=rep(NA, 40), cov= as.character(rep(NA,40)) )

timebin_avg_Sadness<- unique(db_of7_new_avg_Sadness$timebin)
# test.data$timebinout<- as.vector(timebinout) # add the curerent timebins to that vector

# empty list of test results
testresults_avg_Sadness<- list()
# lmer


# currently we have 15 time bins
# the loop below does
# 1 - goes from element i ina  list of eleements 1 to the last time bind_cols
# 2- runs a lmer model regresing face distance to morph vs original, while controling for intercepts of dataset and intercept of unique faces
#3 - stores the result of the model
#4- store informatio on the bin tested, the coeficients, p values and t tests
# morph variance is almost zerp
# dtaset is highly correleted, so ignore


i = 2
for (i in 1:length(timebin_avg_Sadness)) {
  # Surprise_results<- t.test(log1p(D1+.1) ~ morph,var.equal = FALSE, paired = FALSE, data = db_of7_new[db_of7_new$timestamp == timebinout[i],])
  avg_Sadness_results<- lmer(log1p(D1+.1) ~ morph + (1 |face_unique) + (1 | Dataset),
                      data = db_of7_new_avg_Sadness[db_of7_new_avg_Sadness$timebin == timebin_avg_Sadness[i],])

  # testresults<- lmer(log1p(D1+.1) ~ morph + (1|face_unique),
  #                     data = db_of7_new [db_of7_new$timebin == timebinout[i] & db_of7_new$Dataset !="ADFES",])
  avg_Sadness_results_sum<- summary(avg_Sadness_results)

   test.data_by_avg_Sadness[i,1]<-timebin_avg_Sadness[i]
   test.data_by_avg_Sadness[i,2]<- avg_Sadness_results_sum[["coefficients"]][2,1]
   test.data_by_avg_Sadness[i,3]<- avg_Sadness_results_sum[["coefficients"]][2,4]
   test.data_by_avg_Sadness[i,4]<- avg_Sadness_results_sum[["coefficients"]][2,5]
  #
   
   
  #     test.data_bySurprise[i,1]<-timestamp_Surprise[i]
  # # test.data_bySurprise[i,2]<- Surprise_results_sum[["coefficients"]][2,1]
  #  test.data_bySurprise[i,3]<- Surprise_results$statistic
  #  test.data_bySurprise[i,4]<- Surprise_results$p.value
  #  # test.data[i,5]<- testresults@optinfo$val
   print(i)
}
summary( avg_Sadness_results)
 # test.data_bySurprise1<- test.data_bySurprise
 test.data_by_avg_Sadness$p_holm<- p.adjust(test.data_by_avg_Sadness$p, length(test.data_by_avg_Sadness$p), method = "holm")
 
 test.data_by_avg_Sadness$p_bonf<- p.adjust(test.data_by_avg_Sadness$p, length(test.data_by_avg_Sadness$p), 
                                          method ="bonf")
  View(test.data_by_avg_Sadness)
# now sum adjancet timebins
  # testresults@optinfo$conv$opt$
  
  
  
test.data_by_avg_Sadness<- test.data_by_avg_Sadness %>%
  mutate(poten_clust = if_else(is.na(cluster_counter) == FALSE & cluster_counter > 0, 0,1))

plots_of$avg_Sadness <- 
   test.data_by_avg_Sadness%>%
     ggplot(aes(as.numeric(timebins), t))+
     geom_rect(aes(xmin = timebins, xmax = dplyr::lead(timebins), ymin =4.9 , ymax =5.2 , fill = p), 
            alpha = 0.8)+
     geom_rect(aes(xmin = timebins, xmax = dplyr::lead(timebins), ymin =5.7 , ymax =6 , fill = poten_clust),
            alpha = 0.8)+
     geom_rect(aes(xmin = timebins, xmax = dplyr::lead(timebins), ymin =5.3 , ymax =5.6 , fill = p_bonf), 
            alpha = 0.8)+

     geom_hline(yintercept = 2, linetype = 'dashed', size = 1.5, colour = 'red')+
     stat_summary(geom = 'line', size = 2)+
               theme_classic()+
  geom_hline(yintercept = -2, linetype = 'dashed', size = 1.5, colour = 'red')+
     stat_summary(geom = 'line', size = 2)+
               theme_classic()+
  geom_hline(yintercept = 0, linetype = 'dashed', size = 1.5, colour = 'gray')+
     stat_summary(geom = 'line', size = 2)+
               theme_classic()+
     # ylim(1,6)+
      # scale_fill_viridis_c()+
  # scale_colour_gradient2(mid = "white", limits = c(0,1), midpoint = .5)+
  scale_fill_viridis_c(breaks= c(0, .5, 1), limits = c(0,1))+
  ggtitle("Sadness")+
  xlab("Time (s)")+
  ylab("t statistic")
   
plots_of$avg_Sadness <- plots_of$avg_Sadness+ p$graphstyle+
  guides(fill = guide_colourbar(ticks = FALSE))+
  scale_y_continuous(breaks = c(-6, 0, 6), limits = c(-6,6))
   
plots_of$avg_Sadness




```


SadnessBoostrap

```{r}
View(test.data_by_avg_Sadness)

test.data_by_avg_Sadness <- test.data_by_avg_Sadness %>%
  ungroup()%>%
  mutate(cluster_log = if_else(test.data_by_avg_Sadness$p< .05, TRUE, FALSE))%>%
  mutate(Direction = if_else(t > 0 & cluster_log == TRUE, "Positive", 
                             if_else(t < 0 & cluster_log == TRUE, "Negative", NULL)))%>% # flag direction that is
        # group_by(sim)%>%
        mutate(idx = !is.na(Direction))%>%
        mutate(cluster_counter  = as.numeric(replace(Direction, idx, rleid(rleid(Direction)[idx]))))%>%
      # create a cluster t sum by adjacency, remeber the up there we grouped 
      # cluster counter shuffle makes sure ajancent significant bisn are griuped together
      # direction - do we need thisDirection, cluster_shuffle_log 
      group_by(cluster_counter)%>%
      mutate(t_sum_dir = sum(t))%>%
      # ungroup()%>%
      mutate(t_sum_dir = if_else(cluster_log == TRUE, t_sum_dir, NULL))%>% #summ timebins into clusters statistics
        # create max cluster lavels, store the direction value of the cluster and the label of the direction
      # suppressWarnings
        # group_by(sim)%>%
      mutate(MaxCLust_label = if_else(abs(t_sum_dir) == max(abs(t_sum_dir), na.rm = TRUE),
                                      cluster_counter, NULL ))%>%
      # suppressWarnings
      mutate(MaxCLust_value = if_else(abs(t_sum_dir) == max(abs(t_sum_dir), na.rm = TRUE), 
                                      t_sum_dir, NULL ))%>%
      # suppressWarnings
      mutate(MaxCLust_direction = if_else(MaxCLust_value > 0, "Positive", "Negative"))
View(test.data_by_avg_Sadness)
# negative estmate = morph has less actiation
        
library(data.table)
# create a counter for helpting with cluster by adjancecy

# regular corrections
# test.data_by_avg_Sadness<- test.data_by_avg_Sadness%>%
#   mutate(p_bonf = p.adjust(p, method = 'holm'))%>%
#   mutate(p_holm = p.adjust(p, method = "bonf"))


# go back to the data use to fit - db_of7_new[db_of7_new$timestamp == timebinout_avg[i],])
nrow(db_of7_new_avg_Sadness)
db_of7_new_avg_Sadness%>%
  # filter( Emotion == "Sadness")%>%
  group_by(morph)%>%
  summarise(n = n())# 1280/2



i = 1

View(testtemp)

db_of7_new_avg_Sadness%>%
  # filter(Emotion == "Sadness")%>%
  group_by(video, morph)%>%
  summarise(time = mean(timebin, na.rm = TRUE))%>%
  group_by(morph)%>%
  summarise(n = n()) # collapsing time now we have 16 vidoe per videotype
              

timebin_shuff_Sadness<- unique(db_of7_new_avg_Sadness$timebin)

 # create a random arrangment of labels for oroginal and morpj

nsim = 1:1000 #no. of simullation
nbins  =1:40 # numbr of bins. aways check

#create an empty dataframe to store results of the simulation
# remeber to always define it before simulation

simulated_clusters_Sadness<- data.frame(timebins= rep(NA, max(nsim)*max(nbins)), Estimate= rep(NA, max(nsim)*max(nbins)), t=rep(NA, max(nsim)*max(nbins)), p=rep(NA, max(nsim)*max(nbins)), cov= as.character(rep(NA,max(nsim)*max(nbins))), sim = rep(NA, max(nsim)*max(nbins)) )

View(simulated_clusters_Sadness)

# timebin_random_ADFES<- unique(db_of7_new_avg_Sadness$timebin)

# create random labels

i = 1 # remember to always rezero it
# b = 34

seed = 444

simulated_clusters_Sadness$cov<- as.character( simulated_clusters_Sadness$cov) # remeber to run

 i = 1
 # b = 1
 # s = 1
 
 View(db_of7_new_avg_Sadness)
 
 db_of7_new_avg_Sadness$VideoType_contrast<- if_else(db_of7_new_avg_Sadness$morph == "Morph", -.5, .5) # morph == -.5, original .5

 i = 1

for (b in 1:length(nbins)) {
  for (s in 1:length(nsim)) {

    message(sprintf("$$$$$RUNING simulation %i & bin %i", nsim[s], nbins[b]))
    db_of7_new_avg_Sadness$VideoType_contrast_sample<- sample((rep(c(-.5, .5), each =  640)), replace = FALSE) 
        #run the model on the current time bin and simulation sumber
        lmer_bin_random_Sadness  <- lmer(log1p(face_action_AVG +.1) ~ VideoType_contrast_sample + 
                                   (1 |face_unique),
                      data = subset(db_of7_new_avg_Sadness, db_of7_new_avg_Sadness$timebin == timebin_shuff_Sadness[b]))

        #store results from the somularion
            lmer_bin_random_summary_Sadness<- summary(lmer_bin_random_Sadness)
            simulated_clusters_Sadness[i,1]<- timebin_shuff_Sadness[b] #save the exact value of time bin
            simulated_clusters_Sadness[i,2]<- lmer_bin_random_summary_Sadness[["coefficients"]][2,1] # s
            simulated_clusters_Sadness[i,3]<-lmer_bin_random_summary_Sadness[["coefficients"]][2,4] # t statistic
            simulated_clusters_Sadness[i,4]<-lmer_bin_random_summary_Sadness[["coefficients"]][2,5] # p value
            simulated_clusters_Sadness[i,6]<- nsim[s] #store simulation ount
            simulated_clusters_Sadness[i,5] <-ifelse(length(lmer_bin_random_summary_Sadness$optinfo$conv$lme4$message)
                                                   != 0,
                                               lmer_bin_random_summary_Sadness$optinfo$conv$lme4$message, 'pass')

     i = i+1
  }
}




```


Jeffe_emotions

Anger


```{r}
# db_of7_new$Emotion
db_of7_new_JEFFE_avg_Anger<- subset(db_of7_new, db_of7_new$Dataset == "JEFFE" & db_of7_new$Emotion == "Anger")



test.data_by_JEFFE_avg_Anger<- data.frame(timebins= rep(NA, 40), Estimate= rep(NA, 40), t=rep(NA, 40), p=rep(NA, 40), cov= as.character(rep(NA,40)) )

timebin_JEFFE_avg_Anger<- unique(db_of7_new_JEFFE_avg_Anger$timebin)
# test.data$timebinout<- as.vector(timebinout) # add the curerent timebins to that vector

# empty list of test results
testresults_JEFFE_avg_Anger<- list()
# lmer


# currently we have 15 time bins
# the loop below does
# 1 - goes from element i ina  list of eleements 1 to the last time bind_cols
# 2- runs a lmer model regresing face distance to morph vs original, while controling for intercepts of dataset and intercept of unique faces
#3 - stores the result of the model
#4- store informatio on the bin tested, the coeficients, p values and t tests
# morph variance is almost zerp
# dtaset is highly correleted, so ignore


i = 2
for (i in 1:length(timestamp_JEFFE_avg_Anger)) {
  # Surprise_results<- t.test(log1p(D1+.1) ~ morph,var.equal = FALSE, paired = FALSE, data = db_of7_new[db_of7_new$timestamp == timebinout[i],])
  JEFFE_avg_Anger_results<- lmer(log1p(D1+.1) ~ morph + (1 |face_unique),
                      data = db_of7_new_JEFFE_avg_Anger[db_of7_new_JEFFE_avg_Anger$timebin == timebin_JEFFE_avg_Anger[i],])

  # testresults<- lmer(log1p(D1+.1) ~ morph + (1|face_unique),
  #                     data = db_of7_new [db_of7_new$timebin == timebinout[i] & db_of7_new$Dataset !="ADFES",])
  JEFFE_avg_Anger_results_sum<- summary(JEFFE_avg_Anger_results)

   test.data_by_JEFFE_avg_Anger[i,1]<-timebin_JEFFE_avg_Anger[i]
   test.data_by_JEFFE_avg_Anger[i,2]<- JEFFE_avg_Anger_results_sum[["coefficients"]][2,1]
   test.data_by_JEFFE_avg_Anger[i,3]<- JEFFE_avg_Anger_results_sum[["coefficients"]][2,4]
   test.data_by_JEFFE_avg_Anger[i,4]<- JEFFE_avg_Anger_results_sum[["coefficients"]][2,5]
  #
   
   
  #     test.data_bySurprise[i,1]<-timestamp_Surprise[i]
  # # test.data_bySurprise[i,2]<- Surprise_results_sum[["coefficients"]][2,1]
  #  test.data_bySurprise[i,3]<- Surprise_results$statistic
  #  test.data_bySurprise[i,4]<- Surprise_results$p.value
  #  # test.data[i,5]<- testresults@optinfo$val
   print(i)
}
summary( JEFFE_avg_Anger_results)
 # test.data_bySurprise1<- test.data_bySurprise
 test.data_by_JEFFE_avg_Anger$p_holm<- p.adjust(test.data_by_JEFFE_avg_Anger$p, length(test.data_by_JEFFE_avg_Anger$p), method = "holm")
 
 test.data_by_JEFFE_avg_Anger$p_bonf<- p.adjust(test.data_by_JEFFE_avg_Anger$p, length(test.data_by_JEFFE_avg_Anger$p), 
                                          method ="bonf")
  View(test.data_by_JEFFE_avg_Anger)
# now sum adjancet timebins
  # testresults@optinfo$conv$opt$

plots_of$JEFFE_avg_Anger <- 
   test.data_by_JEFFE_avg_Anger%>%
     ggplot(aes(as.numeric(timebins), t))+
     geom_rect(aes(xmin = timebins, xmax = dplyr::lead(timebins), ymin =5.7 , ymax =6 , fill = p_bonf),
            alpha = 0.8)+
     geom_rect(aes(xmin = timebins, xmax = dplyr::lead(timebins), ymin =5.3 , ymax =5.6 , fill = p_holm), 
            alpha = 0.8)+
   geom_rect(aes(xmin = timebins, xmax = dplyr::lead(timebins), ymin =5 , ymax =5.2 , fill = p), 
            alpha = 0.8)+
     geom_hline(yintercept = 2, linetype = 'dashed', size = 1.5, colour = 'red')+
     stat_summary(geom = 'line', size = 2)+
               theme_classic()+
  geom_hline(yintercept = -2, linetype = 'dashed', size = 1.5, colour = 'red')+
     stat_summary(geom = 'line', size = 2)+
               theme_classic()+
     # ylim(1,6)+
      scale_fill_viridis_c()+
     scale_colour_gradient2(mid = "white", limits = c(0,1), midpoint = .5)+
  ggtitle("JEFFE AVG face motion ~ Morph - Anger")
   
plots_of$JEFFE_avg_Anger




```

JEFFE anger boostrap


```{r}
View(test.data_by_JEFFE_avg_Anger)

test.data_by_JEFFE_avg_Anger <- test.data_by_JEFFE_avg_Anger %>%
  ungroup()%>%
  mutate(cluster_log = if_else(test.data_by_JEFFE_avg_Anger$p< .05, TRUE, FALSE))%>%
  mutate(Direction = if_else(t > 0 & cluster_log == TRUE, "Positive", 
                             if_else(t < 0 & cluster_log == TRUE, "Negative", NULL)))%>% # flag direction that is
        # group_by(sim)%>%
        mutate(idx = !is.na(Direction))%>%
        mutate(cluster_counter  = as.numeric(replace(Direction, idx, rleid(rleid(Direction)[idx]))))%>%
      # create a cluster t sum by adjacency, remeber the up there we grouped 
      # cluster counter shuffle makes sure ajancent significant bisn are griuped together
      # direction - do we need thisDirection, cluster_shuffle_log 
      group_by(cluster_counter)%>%
      mutate(t_sum_dir = sum(t))%>%
      # ungroup()%>%
      mutate(t_sum_dir = if_else(cluster_log == TRUE, t_sum_dir, NULL))%>% #summ timebins into clusters statistics
        # create max cluster lavels, store the direction value of the cluster and the label of the direction
      # suppressWarnings
        # group_by(sim)%>%
      mutate(MaxCLust_label = if_else(abs(t_sum_dir) == max(abs(t_sum_dir), na.rm = TRUE),
                                      cluster_counter, NULL ))%>%
      # suppressWarnings
      mutate(MaxCLust_value = if_else(abs(t_sum_dir) == max(abs(t_sum_dir), na.rm = TRUE), 
                                      t_sum_dir, NULL ))%>%
      # suppressWarnings
      mutate(MaxCLust_direction = if_else(MaxCLust_value > 0, "Positive", "Negative"))
View(test.data_by_JEFFE_avg_Anger)
# negative estmate = morph has less actiation
        
library(data.table)
# create a counter for helpting with cluster by adjancecy

# regular corrections
# test.data_by_JEFFE_avg_Anger<- test.data_by_JEFFE_avg_Anger%>%
#   mutate(p_bonf = p.adjust(p, method = 'holm'))%>%
#   mutate(p_holm = p.adjust(p, method = "bonf"))


# go back to the data use to fit - db_of7_new[db_of7_new$timestamp == timebinout_avg[i],])
nrow(db_of7_new_avg_JEFFE_Anger)
db_of7_new_JEFFE_avg_Anger%>%
  # filter( Emotion == "Anger")%>%
  group_by(morph)%>%
  summarise(n = n())# 1280/2



i = 1

View(testtemp)

db_of7_new_JEFFE_avg_Anger%>%
  # filter(Emotion == "Anger")%>%
  group_by(video, morph)%>%
  summarise(time = mean(timebin, na.rm = TRUE))%>%
  group_by(morph)%>%
  summarise(n = n()) # collapsing time now we have 16 vidoe per videotype
              
timebin_shuff_JEFFE_Anger<- unique(db_of7_new_JEFFE_avg_Anger$timebin)

 # create a random arrangment of labels for oroginal and morpj

nsim = 1:1000 #no. of simullation
nbins  =1:40 # numbr of bins. aways check

#create an empty dataframe to store results of the simulation
# remeber to always define it before simulation

simulated_clusters_JEFFE_Anger<- data.frame(timebins= rep(NA, max(nsim)*max(nbins)), Estimate= rep(NA, max(nsim)*max(nbins)), t=rep(NA, max(nsim)*max(nbins)), p=rep(NA, max(nsim)*max(nbins)), cov= as.character(rep(NA,max(nsim)*max(nbins))), sim = rep(NA, max(nsim)*max(nbins)) )

View(simulated_clusters_Anger)

# timebin_random_ADFES<- unique(db_of7_new_JEFFE_avg_Anger$timebin)

# create random labels

i = 1 # remember to always rezero it
# b = 34

seed = 444

simulated_clusters_JEFFE_Anger$cov<- as.character( simulated_clusters_JEFFE_Anger$cov) # remeber to run

 i = 1
 # b = 1
 # s = 1
 
 View(db_of7_new_JEFFE_avg_Anger)
 
 db_of7_new_JEFFE_avg_Anger$VideoType_contrast<- if_else(db_of7_new_JEFFE_avg_Anger$morph == "Morph", -.5, .5) # morph == -.5, original .5

 i = 1

for (b in 1:length(nbins)) {
  for (s in 1:length(nsim)) {

    message(sprintf("$$$$$RUNING simulation %i & bin %i", nsim[s], nbins[b]))
    db_of7_new_JEFFE_avg_Anger$VideoType_contrast_sample<- sample((rep(c(-.5, .5), each =  320)), replace = FALSE) 
        #run the model on the current time bin and simulation sumber
        lmer_bin_random_JEFFE_Anger  <- lmer(log1p(face_action_AVG +.1) ~ VideoType_contrast_sample + 
                                   (1 |face_unique),
                      data = subset(db_of7_new_JEFFE_avg_Anger, db_of7_new_JEFFE_avg_Anger$timebin == timebin_shuff_JEFFE_Anger[b]))

        #store results from the somularion
            lmer_bin_random_summary_JEFFE_Anger<- summary(lmer_bin_random_JEFFE_Anger)
            simulated_clusters_JEFFE_Anger[i,1]<- timebin_shuff_Anger[b] #save the exact value of time bin
            simulated_clusters_JEFFE_Anger[i,2]<- lmer_bin_random_summary_Anger[["coefficients"]][2,1] # s
            simulated_clusters_JEFFE_Anger[i,3]<-lmer_bin_random_summary_Anger[["coefficients"]][2,4] # t statistic
            simulated_clusters_JEFFE_Anger[i,4]<-lmer_bin_random_summary_Anger[["coefficients"]][2,5] # p value
           simulated_clusters_JEFFE_Anger[i,6]<- nsim[s] #store simulation ount
            simulated_clusters_JEFFE_Anger[i,5]<-ifelse(length(lmer_bin_random_summary_Anger$optinfo$conv$lme4$message)
                                                   != 0,
                                               lmer_bin_random_summary_Anger$optinfo$conv$lme4$message, 'pass')

     i = i+1
  }
}




```


Joy

```{r}
# db_of7_new$Emotion
db_of7_new_JEFFE_avg_Joy<- subset(db_of7_new, db_of7_new$Dataset == "JEFFE" & db_of7_new$Emotion == "Joy")



test.data_by_JEFFE_avg_Joy<- data.frame(timebins= rep(NA, 40), Estimate= rep(NA, 40), t=rep(NA, 40), p=rep(NA, 40), cov= as.character(rep(NA,40)) )

timebin_JEFFE_avg_Joy<- unique(db_of7_new_JEFFE_avg_Joy$timebin)
# test.data$timebinout<- as.vector(timebinout) # add the curerent timebins to that vector

# empty list of test results
testresults_JEFFE_avg_Joy<- list()
# lmer


# currently we have 15 time bins
# the loop below does
# 1 - goes from element i ina  list of eleements 1 to the last time bind_cols
# 2- runs a lmer model regresing face distance to morph vs original, while controling for intercepts of dataset and intercept of unique faces
#3 - stores the result of the model
#4- store informatio on the bin tested, the coeficients, p values and t tests
# morph variance is almost zerp
# dtaset is highly correleted, so ignore


i = 2
for (i in 1:length(timebin_JEFFE_avg_Joy)) {
  # Surprise_results<- t.test(log1p(D1+.1) ~ morph,var.equal = FALSE, paired = FALSE, data = db_of7_new[db_of7_new$timestamp == timebinout[i],])
  JEFFE_avg_Joy_results<- lmer(log1p(D1+.1) ~ morph + (1 |face_unique),
                      data = db_of7_new_JEFFE_avg_Joy[db_of7_new_JEFFE_avg_Joy$timebin == timebin_JEFFE_avg_Joy[i],])

  # testresults<- lmer(log1p(D1+.1) ~ morph + (1|face_unique),
  #                     data = db_of7_new [db_of7_new$timebin == timebinout[i] & db_of7_new$Dataset !="ADFES",])
  JEFFE_avg_Joy_results_sum<- summary(JEFFE_avg_Joy_results)

   test.data_by_JEFFE_avg_Joy[i,1]<-timestamp_JEFFE_avg_Joy[i]
   test.data_by_JEFFE_avg_Joy[i,2]<- JEFFE_avg_Joy_results_sum[["coefficients"]][2,1]
   test.data_by_JEFFE_avg_Joy[i,3]<- JEFFE_avg_Joy_results_sum[["coefficients"]][2,4]
   test.data_by_JEFFE_avg_Joy[i,4]<- JEFFE_avg_Joy_results_sum[["coefficients"]][2,5]
  #
   
   
  #     test.data_bySurprise[i,1]<-timestamp_Surprise[i]
  # # test.data_bySurprise[i,2]<- Surprise_results_sum[["coefficients"]][2,1]
  #  test.data_bySurprise[i,3]<- Surprise_results$statistic
  #  test.data_bySurprise[i,4]<- Surprise_results$p.value
  #  # test.data[i,5]<- testresults@optinfo$val
   print(i)
}
summary( JEFFE_avg_Joy_results)
 # test.data_bySurprise1<- test.data_bySurprise
 test.data_by_JEFFE_avg_Joy$p_holm<- p.adjust(test.data_by_JEFFE_avg_Joy$p, length(test.data_by_JEFFE_avg_Joy$p), method = "holm")
 
 test.data_by_JEFFE_avg_Joy$p_bonf<- p.adjust(test.data_by_JEFFE_avg_Joy$p, length(test.data_by_JEFFE_avg_Joy$p), 
                                          method ="bonf")
  View(test.data_by_JEFFE_avg_Joy)
# now sum adjancet timebins
  # testresults@optinfo$conv$opt$

plots_of$JEFFE_avg_Joy <- 
   test.data_by_JEFFE_avg_Joy%>%
     ggplot(aes(as.numeric(timebins), t))+
     geom_rect(aes(xmin = timebins, xmax = dplyr::lead(timebins), ymin =5.7 , ymax =6 , fill = p_bonf),
            alpha = 0.8)+
     geom_rect(aes(xmin = timebins, xmax = dplyr::lead(timebins), ymin =5.3 , ymax =5.6 , fill = p_holm), 
            alpha = 0.8)+
   geom_rect(aes(xmin = timebins, xmax = dplyr::lead(timebins), ymin =5 , ymax =5.2 , fill = p), 
            alpha = 0.8)+
     geom_hline(yintercept = 2, linetype = 'dashed', size = 1.5, colour = 'red')+
     stat_summary(geom = 'line', size = 2)+
               theme_classic()+
  geom_hline(yintercept = -2, linetype = 'dashed', size = 1.5, colour = 'red')+
     stat_summary(geom = 'line', size = 2)+
               theme_classic()+
     # ylim(1,6)+
      # scale_fill_viridis_c()+
   scale_fill_viridis_c(breaks= c(0, .5, 1), limits = c(0,1))+
     # scale_colour_gradient2(mid = "white", limits = c(0,1), midpoint = .5)+
  ggtitle("JEFFE AVG face motion ~ Morph - Joy")
   
plots_of$JEFFE_avg_Joy





```

JOYE JEFFE boostrap
```{r}
View(test.data_by_JEFFE_avg_Joy)

test.data_by_JEFFE_avg_Joy <- test.data_by_JEFFE_avg_Joy %>%
  ungroup()%>%
  mutate(cluster_log = if_else(test.data_by_JEFFE_avg_Joy$p< .05, TRUE, FALSE))%>%
  mutate(Direction = if_else(t > 0 & cluster_log == TRUE, "Positive", 
                             if_else(t < 0 & cluster_log == TRUE, "Negative", NULL)))%>% # flag direction that is
        # group_by(sim)%>%
        mutate(idx = !is.na(Direction))%>%
        mutate(cluster_counter  = as.numeric(replace(Direction, idx, rleid(rleid(Direction)[idx]))))%>%
      # create a cluster t sum by adjacency, remeber the up there we grouped 
      # cluster counter shuffle makes sure ajancent significant bisn are griuped together
      # direction - do we need thisDirection, cluster_shuffle_log 
      group_by(cluster_counter)%>%
      mutate(t_sum_dir = sum(t))%>%
      # ungroup()%>%
      mutate(t_sum_dir = if_else(cluster_log == TRUE, t_sum_dir, NULL))%>% #summ timebins into clusters statistics
        # create max cluster lavels, store the direction value of the cluster and the label of the direction
      # suppressWarnings
        # group_by(sim)%>%
      mutate(MaxCLust_label = if_else(abs(t_sum_dir) == max(abs(t_sum_dir), na.rm = TRUE),
                                      cluster_counter, NULL ))%>%
      # suppressWarnings
      mutate(MaxCLust_value = if_else(abs(t_sum_dir) == max(abs(t_sum_dir), na.rm = TRUE), 
                                      t_sum_dir, NULL ))%>%
      # suppressWarnings
      mutate(MaxCLust_direction = if_else(MaxCLust_value > 0, "Positive", "Negative"))
View(test.data_by_JEFFE_avg_Joy)
# negative estmate = morph has less actiation
        
library(data.table)
# create a counter for helpting with cluster by adjancecy

# regular corrections
# test.data_by_JEFFE_avg_Joy<- test.data_by_JEFFE_avg_Joy%>%
#   mutate(p_bonf = p.adjust(p, method = 'holm'))%>%
#   mutate(p_holm = p.adjust(p, method = "bonf"))


# go back to the data use to fit - db_of7_new[db_of7_new$timestamp == timebinout_avg[i],])
nrow(db_of7_new_avg_JEFFE_Joy)
db_of7_new_JEFFE_avg_Joy%>%
  # filter( Emotion == "Joy")%>%
  group_by(morph)%>%
  summarise(n = n())# 1280/2



i = 1

View(testtemp)

db_of7_new_JEFFE_avg_Joy%>%
  # filter(Emotion == "Joy")%>%
  group_by(video, morph)%>%
  summarise(time = mean(timebin, na.rm = TRUE))%>%
  group_by(morph)%>%
  summarise(n = n()) # collapsing time now we have 16 vidoe per videotype
              
timebin_shuff_JEFFE_Joy<- unique(db_of7_new_JEFFE_avg_Joy$timebin)

 # create a random arrangment of labels for oroginal and morpj

nsim = 1:1000 #no. of simullation
nbins  =1:40 # numbr of bins. aways check

#create an empty dataframe to store results of the simulation
# remeber to always define it before simulation

simulated_clusters_JEFFE_Joy<- data.frame(timebins= rep(NA, max(nsim)*max(nbins)), Estimate= rep(NA, max(nsim)*max(nbins)), t=rep(NA, max(nsim)*max(nbins)), p=rep(NA, max(nsim)*max(nbins)), cov= as.character(rep(NA,max(nsim)*max(nbins))), sim = rep(NA, max(nsim)*max(nbins)) )

View(simulated_clusters_Joy)

# timebin_random_ADFES<- unique(db_of7_new_JEFFE_avg_Joy$timebin)

# create random labels

i = 1 # remember to always rezero it
# b = 34

seed = 444

simulated_clusters_JEFFE_Joy$cov<- as.character( simulated_clusters_JEFFE_Joy$cov) # remeber to run

 i = 1
 # b = 1
 # s = 1
 
 View(db_of7_new_JEFFE_avg_Joy)
 
 db_of7_new_JEFFE_avg_Joy$VideoType_contrast<- if_else(db_of7_new_JEFFE_avg_Joy$morph == "Morph", -.5, .5) # morph == -.5, original .5

 i = 1

for (b in 1:length(nbins)) {
  for (s in 1:length(nsim)) {

    message(sprintf("$$$$$RUNING simulation %i & bin %i", nsim[s], nbins[b]))
    db_of7_new_JEFFE_avg_Joy$VideoType_contrast_sample<- sample((rep(c(-.5, .5), each =  320)), replace = FALSE) 
        #run the model on the current time bin and simulation sumber
        lmer_bin_random_JEFFE_Joy  <- lmer(log1p(face_action_AVG +.1) ~ VideoType_contrast_sample + 
                                   (1 |face_unique),
                      data = subset(db_of7_new_JEFFE_avg_Joy, db_of7_new_JEFFE_avg_Joy$timebin == timebin_shuff_JEFFE_Joy[b]))

        #store results from the somularion
            lmer_bin_random_summary_JEFFE_Joy<- summary(lmer_bin_random_JEFFE_Joy)
            simulated_clusters_JEFFE_Joy[i,1]<- timebin_shuff_Joy[b] #save the exact value of time bin
            simulated_clusters_JEFFE_Joy[i,2]<- lmer_bin_random_summary_Joy[["coefficients"]][2,1] # s
            simulated_clusters_JEFFE_Joy[i,3]<-lmer_bin_random_summary_Joy[["coefficients"]][2,4] # t statistic
            simulated_clusters_JEFFE_Joy[i,4]<-lmer_bin_random_summary_Joy[["coefficients"]][2,5] # p value
           simulated_clusters_JEFFE_Joy[i,6]<- nsim[s] #store simulation ount
            simulated_clusters_JEFFE_Joy[i,5]<-ifelse(length(lmer_bin_random_summary_Joy$optinfo$conv$lme4$message)
                                                   != 0,
                                               lmer_bin_random_summary_Joy$optinfo$conv$lme4$message, 'pass')

     i = i+1
  }
}

```



Sadness
```{r}
# db_of7_new$Emotion
db_of7_new_JEFFE_avg_Sadness<- subset(db_of7_new, db_of7_new$Dataset == "JEFFE" & db_of7_new$Emotion == "Sadness")



test.data_by_JEFFE_avg_Sadness<- data.frame(timebins= rep(NA, 40), Estimate= rep(NA, 40), t=rep(NA, 40), p=rep(NA, 40), cov= as.character(rep(NA,40)) )

timebin_JEFFE_avg_Sadness<- unique(db_of7_new_JEFFE_avg_Sadness$timebin)
# test.data$timebinout<- as.vector(timebinout) # add the curerent timebins to that vector

# empty list of test results
testresults_JEFFE_avg_Sadness<- list()
# lmer


# currently we have 15 time bins
# the loop below does
# 1 - goes from element i ina  list of eleements 1 to the last time bind_cols
# 2- runs a lmer model regresing face distance to morph vs original, while controling for intercepts of dataset and intercept of unique faces
#3 - stores the result of the model
#4- store informatio on the bin tested, the coeficients, p values and t tests
# morph variance is almost zerp
# dtaset is highly correleted, so ignore


i = 2
for (i in 1:length(timebin_JEFFE_avg_Sadness)) {
  # Surprise_results<- t.test(log1p(D1+.1) ~ morph,var.equal = FALSE, paired = FALSE, data = db_of7_new[db_of7_new$timestamp == timebinout[i],])
  JEFFE_avg_Sadness_results<- lmer(log1p(D1+.1) ~ morph + (1 |face_unique),
                      data = db_of7_new_JEFFE_avg_Sadness[db_of7_new_JEFFE_avg_Sadness$timebin == timebin_JEFFE_avg_Sadness[i],])

  # testresults<- lmer(log1p(D1+.1) ~ morph + (1|face_unique),
  #                     data = db_of7_new [db_of7_new$timebin == timebinout[i] & db_of7_new$Dataset !="ADFES",])
  JEFFE_avg_Sadness_results_sum<- summary(JEFFE_avg_Sadness_results)

   test.data_by_JEFFE_avg_Sadness[i,1]<-timebin_JEFFE_avg_Sadness[i]
   test.data_by_JEFFE_avg_Sadness[i,2]<- JEFFE_avg_Sadness_results_sum[["coefficients"]][2,1]
   test.data_by_JEFFE_avg_Sadness[i,3]<- JEFFE_avg_Sadness_results_sum[["coefficients"]][2,4]
   test.data_by_JEFFE_avg_Sadness[i,4]<- JEFFE_avg_Sadness_results_sum[["coefficients"]][2,5]
  #
   
   
  #     test.data_bySurprise[i,1]<-timestamp_Surprise[i]
  # # test.data_bySurprise[i,2]<- Surprise_results_sum[["coefficients"]][2,1]
  #  test.data_bySurprise[i,3]<- Surprise_results$statistic
  #  test.data_bySurprise[i,4]<- Surprise_results$p.value
  #  # test.data[i,5]<- testresults@optinfo$val
   print(i)
}
summary( JEFFE_avg_Sadness_results)
 # test.data_bySurprise1<- test.data_bySurprise
test.data_by_JEFFE_avg_Sadness$p_holm<- p.adjust(test.data_by_JEFFE_avg_Sadness$p, length(test.data_by_JEFFE_avg_Sadness$p), method = "holm")
 
 test.data_by_JEFFE_avg_Sadness$p_bonf<- p.adjust(test.data_by_JEFFE_avg_Sadness$p, length(test.data_by_JEFFE_avg_Sadness$p), 
                                          method ="bonf")
  View(test.data_by_JEFFE_avg_Sadness)
# now sum adjancet timebins
  # testresults@optinfo$conv$opt$

plots_of$JEFFE_avg_Sadness <- 
   test.data_by_JEFFE_avg_Sadness%>%
     ggplot(aes(as.numeric(timebins), t))+
     geom_rect(aes(xmin = timebins, xmax = dplyr::lead(timebins), ymin =5.7 , ymax =6 , fill = p_bonf),
            alpha = 0.8)+
     geom_rect(aes(xmin = timebins, xmax = dplyr::lead(timebins), ymin =5.3 , ymax =5.6 , fill = p_holm), 
            alpha = 0.8)+
   geom_rect(aes(xmin = timebins, xmax = dplyr::lead(timebins), ymin =5 , ymax =5.2 , fill = p), 
            alpha = 0.8)+
     geom_hline(yintercept = 2, linetype = 'dashed', size = 1.5, colour = 'red')+
     stat_summary(geom = 'line', size = 2)+
               theme_classic()+
  geom_hline(yintercept = -2, linetype = 'dashed', size = 1.5, colour = 'red')+
     stat_summary(geom = 'line', size = 2)+
               theme_classic()+
     # ylim(1,6)+
      scale_fill_viridis_c()+
     scale_colour_gradient2(mid = "white", limits = c(0,1), midpoint = .5)+
  ggtitle("JEFFE AVG face motion ~ Morph - Sadness")
   
plots_of$JEFFE_avg_Sadness



```


Sadness boostrap

```{r}
View(test.data_by_JEFFE_avg_Sadness)

test.data_by_JEFFE_avg_Sadness <- test.data_by_JEFFE_avg_Sadness %>%
  ungroup()%>%
  mutate(cluster_log = if_else(test.data_by_JEFFE_avg_Sadness$p< .05, TRUE, FALSE))%>%
  mutate(Direction = if_else(t > 0 & cluster_log == TRUE, "Positive", 
                             if_else(t < 0 & cluster_log == TRUE, "Negative", NULL)))%>% # flag direction that is
        # group_by(sim)%>%
        mutate(idx = !is.na(Direction))%>%
        mutate(cluster_counter  = as.numeric(replace(Direction, idx, rleid(rleid(Direction)[idx]))))%>%
      # create a cluster t sum by adjacency, remeber the up there we grouped 
      # cluster counter shuffle makes sure ajancent significant bisn are griuped together
      # direction - do we need thisDirection, cluster_shuffle_log 
      group_by(cluster_counter)%>%
      mutate(t_sum_dir = sum(t))%>%
      # ungroup()%>%
      mutate(t_sum_dir = if_else(cluster_log == TRUE, t_sum_dir, NULL))%>% #summ timebins into clusters statistics
        # create max cluster lavels, store the direction value of the cluster and the label of the direction
      # suppressWarnings
        # group_by(sim)%>%
      mutate(MaxCLust_label = if_else(abs(t_sum_dir) == max(abs(t_sum_dir), na.rm = TRUE),
                                      cluster_counter, NULL ))%>%
      # suppressWarnings
      mutate(MaxCLust_value = if_else(abs(t_sum_dir) == max(abs(t_sum_dir), na.rm = TRUE), 
                                      t_sum_dir, NULL ))%>%
      # suppressWarnings
      mutate(MaxCLust_direction = if_else(MaxCLust_value > 0, "Positive", "Negative"))
View(test.data_by_JEFFE_avg_Sadness)
# negative estmate = morph has less actiation
        
library(data.table)
# create a counter for helpting with cluster by adjancecy

# regular corrections
# test.data_by_JEFFE_avg_Sadness<- test.data_by_JEFFE_avg_Sadness%>%
#   mutate(p_bonf = p.adjust(p, method = 'holm'))%>%
#   mutate(p_holm = p.adjust(p, method = "bonf"))


# go back to the data use to fit - db_of7_new[db_of7_new$timestamp == timebinout_avg[i],])
nrow(db_of7_new_avg_JEFFE_Sadness)
db_of7_new_JEFFE_avg_Sadness%>%
  # filter( Emotion == "Sadness")%>%
  group_by(morph)%>%
  summarise(n = n())# 1280/2



i = 1

View(testtemp)

db_of7_new_JEFFE_avg_Sadness%>%
  # filter(Emotion == "Sadness")%>%
  group_by(video, morph)%>%
  summarise(time = mean(timebin, na.rm = TRUE))%>%
  group_by(morph)%>%
  summarise(n = n()) # collapsing time now we have 16 vidoe per videotype
              
timebin_shuff_JEFFE_Sadness<- unique(db_of7_new_JEFFE_avg_Sadness$timebin)

 # create a random arrangment of labels for oroginal and morpj

nsim = 1:1000 #no. of simullation
nbins  =1:40 # numbr of bins. aways check
seed(444)
#create an empty dataframe to store results of the simulation
# remeber to always define it before simulation

simulated_clusters_JEFFE_Sadness<- data.frame(timebins= rep(NA, max(nsim)*max(nbins)), Estimate= rep(NA, max(nsim)*max(nbins)), t=rep(NA, max(nsim)*max(nbins)), p=rep(NA, max(nsim)*max(nbins)), cov= as.character(rep(NA,max(nsim)*max(nbins))), sim = rep(NA, max(nsim)*max(nbins)) )

View(simulated_clusters_JEFFE_Sadness)

# timebin_random_ADFES<- unique(db_of7_new_JEFFE_avg_Sadness$timebin)

# create random labels

i = 1 # remember to always rezero it
# b = 34

seed = 444

simulated_clusters_JEFFE_Sadness$cov<- as.character( simulated_clusters_JEFFE_Sadness$cov) # remeber to run

 i = 1
 # b = 1
 # s = 1
 
 View(db_of7_new_JEFFE_avg_Sadness)
 
 db_of7_new_JEFFE_avg_Sadness$VideoType_contrast<- if_else(db_of7_new_JEFFE_avg_Sadness$morph == "Morph", -.5, .5) # morph == -.5, original .5

 i = 1

for (b in 1:length(nbins)) {
  for (s in 1:length(nsim)) {

    message(sprintf("$$$$$RUNING simulation %i & bin %i", nsim[s], nbins[b]))
    db_of7_new_JEFFE_avg_Sadness$VideoType_contrast_sample<- sample((rep(c(-.5, .5), each =  320)), replace = FALSE) 
        #run the model on the current time bin and simulation sumber
        lmer_bin_random_JEFFE_Sadness  <- lmer(log1p(face_action_AVG +.1) ~ VideoType_contrast_sample + 
                                   (1 |face_unique),
                      data = subset(db_of7_new_JEFFE_avg_Sadness, db_of7_new_JEFFE_avg_Sadness$timebin == timebin_shuff_JEFFE_Sadness[b]))

        #store results from the somularion
            lmer_bin_random_summary_JEFFE_Sadness<- summary(lmer_bin_random_JEFFE_Sadness)
            simulated_clusters_JEFFE_Sadness[i,1]<- timebin_shuff_Sadness[b] #save the exact value of time bin
            simulated_clusters_JEFFE_Sadness[i,2]<- lmer_bin_random_summary_Sadness[["coefficients"]][2,1] # s
            simulated_clusters_JEFFE_Sadness[i,3]<-lmer_bin_random_summary_Sadness[["coefficients"]][2,4] # t statistic
            simulated_clusters_JEFFE_Sadness[i,4]<-lmer_bin_random_summary_Sadness[["coefficients"]][2,5] # p value
           simulated_clusters_JEFFE_Sadness[i,6]<- nsim[s] #store simulation ount
            simulated_clusters_JEFFE_Sadness[i,5]<-ifelse(length(lmer_bin_random_summary_Sadness$optinfo$conv$lme4$message)
                                                   != 0,
                                               lmer_bin_random_summary_Sadness$optinfo$conv$lme4$message, 'pass')

     i = i+1
  }
}

```


Fear

```{r}
# db_of7_new$Emotion
db_of7_new_JEFFE_avg_Fear<- subset(db_of7_new, db_of7_new$Dataset == "JEFFE" & db_of7_new$Emotion == "Fear")



test.data_by_JEFFE_avg_Fear<- data.frame(timebins= rep(NA, 40), Estimate= rep(NA, 40), t=rep(NA, 40), p=rep(NA, 40), cov= as.character(rep(NA,40)) )

timebin_JEFFE_avg_Fear<- unique(db_of7_new_JEFFE_avg_Fear$timebin)
# test.data$timebinout<- as.vector(timebinout) # add the curerent timebins to that vector

# empty list of test results
testresults_JEFFE_avg_Fear<- list()
# lmer


# currently we have 15 time bins
# the loop below does
# 1 - goes from element i ina  list of eleements 1 to the last time bind_cols
# 2- runs a lmer model regresing face distance to morph vs original, while controling for intercepts of dataset and intercept of unique faces
#3 - stores the result of the model
#4- store informatio on the bin tested, the coeficients, p values and t tests
# morph variance is almost zerp
# dtaset is highly correleted, so ignore


i = 2
for (i in 1:length(timebin_JEFFE_avg_Fear)) {
  # Surprise_results<- t.test(log1p(D1+.1) ~ morph,var.equal = FALSE, paired = FALSE, data = db_of7_new[db_of7_new$timestamp == timebinout[i],])
  JEFFE_avg_Fear_results<- lmer(log1p(D1+.1) ~ morph + (1 |face_unique),
                      data = db_of7_new_JEFFE_avg_Fear[db_of7_new_JEFFE_avg_Fear$timebin == timebin_JEFFE_avg_Fear[i],])

  # testresults<- lmer(log1p(D1+.1) ~ morph + (1|face_unique),
  #                     data = db_of7_new [db_of7_new$timebin == timebinout[i] & db_of7_new$Dataset !="ADFES",])
  JEFFE_avg_Fear_results_sum<- summary(JEFFE_avg_Fear_results)

   test.data_by_JEFFE_avg_Fear[i,1]<-timestamp_JEFFE_avg_Fear[i]
   test.data_by_JEFFE_avg_Fear[i,2]<- JEFFE_avg_Fear_results_sum[["coefficients"]][2,1]
   test.data_by_JEFFE_avg_Fear[i,3]<- JEFFE_avg_Fear_results_sum[["coefficients"]][2,4]
   test.data_by_JEFFE_avg_Fear[i,4]<- JEFFE_avg_Fear_results_sum[["coefficients"]][2,5]
  #
   
   
  #     test.data_bySurprise[i,1]<-timestamp_Surprise[i]
  # # test.data_bySurprise[i,2]<- Surprise_results_sum[["coefficients"]][2,1]
  #  test.data_bySurprise[i,3]<- Surprise_results$statistic
  #  test.data_bySurprise[i,4]<- Surprise_results$p.value
  #  # test.data[i,5]<- testresults@optinfo$val
   print(i)
}
summary( JEFFE_avg_Fear_results)
 # test.data_bySurprise1<- test.data_bySurprise
 test.data_by_JEFFE_avg_Fear$p_holm<- p.adjust(test.data_by_JEFFE_avg_Fear$p, length(test.data_by_JEFFE_avg_Fear$p), method = "holm")
 
 test.data_by_JEFFE_avg_Fear$p_bonf<- p.adjust(test.data_by_JEFFE_avg_Fear$p, length(test.data_by_JEFFE_avg_Fear$p), 
                                          method ="bonf")
  View(test.data_by_JEFFE_avg_Fear)
# now sum adjancet timebins
  # testresults@optinfo$conv$opt$

plots_of$JEFFE_avg_Fear <- 
   test.data_by_JEFFE_avg_Fear%>%
     ggplot(aes(as.numeric(timebins), t))+
     geom_rect(aes(xmin = timebins, xmax = dplyr::lead(timebins), ymin =5.7 , ymax =6 , fill = p_bonf),
            alpha = 0.8)+
     geom_rect(aes(xmin = timebins, xmax = dplyr::lead(timebins), ymin =5.3 , ymax =5.6 , fill = p_holm), 
            alpha = 0.8)+
   geom_rect(aes(xmin = timebins, xmax = dplyr::lead(timebins), ymin =5 , ymax =5.2 , fill = p), 
            alpha = 0.8)+
     geom_hline(yintercept = 2, linetype = 'dashed', size = 1.5, colour = 'red')+
     stat_summary(geom = 'line', size = 2)+
               theme_classic()+
  geom_hline(yintercept = -2, linetype = 'dashed', size = 1.5, colour = 'red')+
     stat_summary(geom = 'line', size = 2)+
               theme_classic()+
     # ylim(1,6)+
      scale_fill_viridis_c()+
     scale_colour_gradient2(mid = "white", limits = c(0,1), midpoint = .5)+
  ggtitle("JEFFE AVG face motion ~ Morph - Fear")
   
plots_of$JEFFE_avg_Fear



```



Fear JEFFE boostrap

```{r}

View(test.data_by_JEFFE_avg_Fear)

test.data_by_JEFFE_avg_Fear <- test.data_by_JEFFE_avg_Fear %>%
  ungroup()%>%
  mutate(cluster_log = if_else(test.data_by_JEFFE_avg_Fear$p< .05, TRUE, FALSE))%>%
  mutate(Direction = if_else(t > 0 & cluster_log == TRUE, "Positive", 
                             if_else(t < 0 & cluster_log == TRUE, "Negative", NULL)))%>% # flag direction that is
        # group_by(sim)%>%
        mutate(idx = !is.na(Direction))%>%
        mutate(cluster_counter  = as.numeric(replace(Direction, idx, rleid(rleid(Direction)[idx]))))%>%
      # create a cluster t sum by adjacency, remeber the up there we grouped 
      # cluster counter shuffle makes sure ajancent significant bisn are griuped together
      # direction - do we need thisDirection, cluster_shuffle_log 
      group_by(cluster_counter)%>%
      mutate(t_sum_dir = sum(t))%>%
      # ungroup()%>%
      mutate(t_sum_dir = if_else(cluster_log == TRUE, t_sum_dir, NULL))%>% #summ timebins into clusters statistics
        # create max cluster lavels, store the direction value of the cluster and the label of the direction
      # suppressWarnings
        # group_by(sim)%>%
      mutate(MaxCLust_label = if_else(abs(t_sum_dir) == max(abs(t_sum_dir), na.rm = TRUE),
                                      cluster_counter, NULL ))%>%
      # suppressWarnings
      mutate(MaxCLust_value = if_else(abs(t_sum_dir) == max(abs(t_sum_dir), na.rm = TRUE), 
                                      t_sum_dir, NULL ))%>%
      # suppressWarnings
      mutate(MaxCLust_direction = if_else(MaxCLust_value > 0, "Positive", "Negative"))
View(test.data_by_JEFFE_avg_Fear)
# negative estmate = morph has less actiation
        
library(data.table)
# create a counter for helpting with cluster by adjancecy

# regular corrections
# test.data_by_JEFFE_avg_Fear<- test.data_by_JEFFE_avg_Fear%>%
#   mutate(p_bonf = p.adjust(p, method = 'holm'))%>%
#   mutate(p_holm = p.adjust(p, method = "bonf"))


# go back to the data use to fit - db_of7_new[db_of7_new$timestamp == timebinout_avg[i],])
nrow(db_of7_new_avg_JEFFE_Fear)
db_of7_new_JEFFE_avg_Fear%>%
  # filter( Emotion == "Fear")%>%
  group_by(morph)%>%
  summarise(n = n())# 1280/2



i = 1

View(testtemp)

db_of7_new_JEFFE_avg_Fear%>%
  # filter(Emotion == "Fear")%>%
  group_by(video, morph)%>%
  summarise(time = mean(timebin, na.rm = TRUE))%>%
  group_by(morph)%>%
  summarise(n = n()) # collapsing time now we have 16 vidoe per videotype
              
timebin_shuff_JEFFE_Fear<- unique(db_of7_new_JEFFE_avg_Fear$timebin)

 # create a random arrangment of labels for oroginal and morpj

nsim = 1:1000 #no. of simullation
nbins  =1:40 # numbr of bins. aways check
seed(444)
#create an empty dataframe to store results of the simulation
# remeber to always define it before simulation

simulated_clusters_JEFFE_Fear<- data.frame(timebins= rep(NA, max(nsim)*max(nbins)), Estimate= rep(NA, max(nsim)*max(nbins)), t=rep(NA, max(nsim)*max(nbins)), p=rep(NA, max(nsim)*max(nbins)), cov= as.character(rep(NA,max(nsim)*max(nbins))), sim = rep(NA, max(nsim)*max(nbins)) )

View(simulated_clusters_JEFFE_Fear)

# timebin_random_ADFES<- unique(db_of7_new_JEFFE_avg_Fear$timebin)

# create random labels

i = 1 # remember to always rezero it
# b = 34

seed = 444

simulated_clusters_JEFFE_Fear$cov<- as.character( simulated_clusters_JEFFE_Fear$cov) # remeber to run

 i = 1
 # b = 1
 # s = 1
 
 View(db_of7_new_JEFFE_avg_Fear)
 
 db_of7_new_JEFFE_avg_Fear$VideoType_contrast<- if_else(db_of7_new_JEFFE_avg_Fear$morph == "Morph", -.5, .5) # morph == -.5, original .5

 i = 1

for (b in 1:length(nbins)) {
  for (s in 1:length(nsim)) {

    message(sprintf("$$$$$RUNING simulation %i & bin %i", nsim[s], nbins[b]))
    db_of7_new_JEFFE_avg_Fear$VideoType_contrast_sample<- sample((rep(c(-.5, .5), each =  320)), replace = FALSE) 
        #run the model on the current time bin and simulation sumber
        lmer_bin_random_JEFFE_Fear  <- lmer(log1p(face_action_AVG +.1) ~ VideoType_contrast_sample + 
                                   (1 |face_unique),
                      data = subset(db_of7_new_JEFFE_avg_Fear, db_of7_new_JEFFE_avg_Fear$timebin == timebin_shuff_JEFFE_Fear[b]))

        #store results from the somularion
            lmer_bin_random_summary_JEFFE_Fear<- summary(lmer_bin_random_JEFFE_Fear)
            simulated_clusters_JEFFE_Fear[i,1]<- timebin_shuff_Fear[b] #save the exact value of time bin
            simulated_clusters_JEFFE_Fear[i,2]<- lmer_bin_random_summary_Fear[["coefficients"]][2,1] # s
            simulated_clusters_JEFFE_Fear[i,3]<-lmer_bin_random_summary_Fear[["coefficients"]][2,4] # t statistic
            simulated_clusters_JEFFE_Fear[i,4]<-lmer_bin_random_summary_Fear[["coefficients"]][2,5] # p value
           simulated_clusters_JEFFE_Fear[i,6]<- nsim[s] #store simulation ount
            simulated_clusters_JEFFE_Fear[i,5]<-ifelse(length(lmer_bin_random_summary_Fear$optinfo$conv$lme4$message)
                                                   != 0,
                                               lmer_bin_random_summary_Fear$optinfo$conv$lme4$message, 'pass')

     i = i+1
  }
}





```

Disgust
```{r}
# db_of7_new$Emotion
db_of7_new_JEFFE_avg_Disgust<- subset(db_of7_new, db_of7_new$Dataset == "JEFFE" & db_of7_new$Emotion == "Disgust")



test.data_by_JEFFE_avg_Disgust<- data.frame(timebins= rep(NA, 40), Estimate= rep(NA, 40), t=rep(NA, 40), p=rep(NA, 40), cov= as.character(rep(NA,40)) )

timebin_JEFFE_avg_Disgust<- unique(db_of7_new_JEFFE_avg_Disgust$timebin)
# test.data$timebinout<- as.vector(timebinout) # add the curerent timebins to that vector

# empty list of test results
testresults_JEFFE_avg_Disgust<- list()
# lmer


# currently we have 15 time bins
# the loop below does
# 1 - goes from element i ina  list of eleements 1 to the last time bind_cols
# 2- runs a lmer model regresing face distance to morph vs original, while controling for intercepts of dataset and intercept of unique faces
#3 - stores the result of the model
#4- store informatio on the bin tested, the coeficients, p values and t tests
# morph variance is almost zerp
# dtaset is highly correleted, so ignore


i = 2
for (i in 1:length(timestamp_JEFFE_avg_Disgust)) {
  # Surprise_results<- t.test(log1p(D1+.1) ~ morph,var.equal = FALSE, paired = FALSE, data = db_of7_new[db_of7_new$timestamp == timebinout[i],])
  JEFFE_avg_Disgust_results<- lmer(log1p(D1+.1) ~ morph + (1 |face_unique),
                      data = db_of7_new_JEFFE_avg_Disgust[db_of7_new_JEFFE_avg_Disgust$timebin == timebin_JEFFE_avg_Disgust[i],])

  # testresults<- lmer(log1p(D1+.1) ~ morph + (1|face_unique),
  #                     data = db_of7_new [db_of7_new$timebin == timebinout[i] & db_of7_new$Dataset !="ADFES",])
  JEFFE_avg_Disgust_results_sum<- summary(JEFFE_avg_Disgust_results)

   test.data_by_JEFFE_avg_Disgust[i,1]<-timebin_JEFFE_avg_Disgust[i]
   test.data_by_JEFFE_avg_Disgust[i,2]<- JEFFE_avg_Disgust_results_sum[["coefficients"]][2,1]
   test.data_by_JEFFE_avg_Disgust[i,3]<- JEFFE_avg_Disgust_results_sum[["coefficients"]][2,4]
   test.data_by_JEFFE_avg_Disgust[i,4]<- JEFFE_avg_Disgust_results_sum[["coefficients"]][2,5]
  #
   
   
  #     test.data_bySurprise[i,1]<-timestamp_Surprise[i]
  # # test.data_bySurprise[i,2]<- Surprise_results_sum[["coefficients"]][2,1]
  #  test.data_bySurprise[i,3]<- Surprise_results$statistic
  #  test.data_bySurprise[i,4]<- Surprise_results$p.value
  #  # test.data[i,5]<- testresults@optinfo$val
   print(i)
}

summary( JEFFE_avg_Disgust_results)
 # test.data_bySurprise1<- test.data_bySurprise
 test.data_by_JEFFE_avg_Disgust$p_holm<- p.adjust(test.data_by_JEFFE_avg_Disgust$p, length(test.data_by_JEFFE_avg_Disgust$p), method = "holm")
 
 test.data_by_JEFFE_avg_Disgust$p_bonf<- p.adjust(test.data_by_JEFFE_avg_Disgust$p, length(test.data_by_JEFFE_avg_Disgust$p), 
                                          method ="bonf")
  View(test.data_by_JEFFE_avg_Disgust)
# now sum adjancet timebins
  # testresults@optinfo$conv$opt$

plots_of$JEFFE_avg_Disgust <- 
   test.data_by_JEFFE_avg_Disgust%>%
     ggplot(aes(as.numeric(timebins), t))+
     geom_rect(aes(xmin = timebins, xmax = dplyr::lead(timebins), ymin =5.7 , ymax =6 , fill = p_bonf),
            alpha = 0.8)+
     geom_rect(aes(xmin = timebins, xmax = dplyr::lead(timebins), ymin =5.3 , ymax =5.6 , fill = p_holm), 
            alpha = 0.8)+
   geom_rect(aes(xmin = timebins, xmax = dplyr::lead(timebins), ymin =5 , ymax =5.2 , fill = p), 
            alpha = 0.8)+
     geom_hline(yintercept = 2, linetype = 'dashed', size = 1.5, colour = 'red')+
     stat_summary(geom = 'line', size = 2)+
               theme_classic()+
  geom_hline(yintercept = -2, linetype = 'dashed', size = 1.5, colour = 'red')+
     stat_summary(geom = 'line', size = 2)+
               theme_classic()+
     # ylim(1,6)+
      scale_fill_viridis_c()+
     scale_colour_gradient2(mid = "white", limits = c(0,1), midpoint = .5)+
  ggtitle("JEFFE AVG face motion ~ Morph - Disgust")
   
plots_of$JEFFE_avg_Disgust





```


View(test.data_by_JEFFE_avg_Sadness)

```{r}
test.data_by_JEFFE_avg_Disgust <- test.data_by_JEFFE_avg_Disgust %>%
  ungroup()%>%
  mutate(cluster_log = if_else(test.data_by_JEFFE_avg_Disgust$p< .05, TRUE, FALSE))%>%
  mutate(Direction = if_else(t > 0 & cluster_log == TRUE, "Positive", 
                             if_else(t < 0 & cluster_log == TRUE, "Negative", NULL)))%>% # flag direction that is
        # group_by(sim)%>%
        mutate(idx = !is.na(Direction))%>%
        mutate(cluster_counter  = as.numeric(replace(Direction, idx, rleid(rleid(Direction)[idx]))))%>%
      # create a cluster t sum by adjacency, remeber the up there we grouped 
      # cluster counter shuffle makes sure ajancent significant bisn are griuped together
      # direction - do we need thisDirection, cluster_shuffle_log 
      group_by(cluster_counter)%>%
      mutate(t_sum_dir = sum(t))%>%
      # ungroup()%>%
      mutate(t_sum_dir = if_else(cluster_log == TRUE, t_sum_dir, NULL))%>% #summ timebins into clusters statistics
        # create max cluster lavels, store the direction value of the cluster and the label of the direction
      # suppressWarnings
        # group_by(sim)%>%
      mutate(MaxCLust_label = if_else(abs(t_sum_dir) == max(abs(t_sum_dir), na.rm = TRUE),
                                      cluster_counter, NULL ))%>%
      # suppressWarnings
      mutate(MaxCLust_value = if_else(abs(t_sum_dir) == max(abs(t_sum_dir), na.rm = TRUE), 
                                      t_sum_dir, NULL ))%>%
      # suppressWarnings
      mutate(MaxCLust_direction = if_else(MaxCLust_value > 0, "Positive", "Negative"))
View(test.data_by_JEFFE_avg_Disgust)
# negative estmate = morph has less actiation
        
library(data.table)
# create a counter for helpting with cluster by adjancecy

# regular corrections
# test.data_by_JEFFE_avg_Disgust<- test.data_by_JEFFE_avg_Disgust%>%
#   mutate(p_bonf = p.adjust(p, method = 'holm'))%>%
#   mutate(p_holm = p.adjust(p, method = "bonf"))


# go back to the data use to fit - db_of7_new[db_of7_new$timestamp == timebinout_avg[i],])
nrow(db_of7_new_avg_JEFFE_Disgust)
db_of7_new_JEFFE_avg_Disgust%>%
  # filter( Emotion == "Disgust")%>%
  group_by(morph)%>%
  summarise(n = n())# 1280/2



i = 1

View(testtemp)

db_of7_new_JEFFE_avg_Disgust%>%
  # filter(Emotion == "Disgust")%>%
  group_by(video, morph)%>%
  summarise(time = mean(timebin, na.rm = TRUE))%>%
  group_by(morph)%>%
  summarise(n = n()) # collapsing time now we have 16 vidoe per videotype
              
timebin_shuff_JEFFE_Disgust<- unique(db_of7_new_JEFFE_avg_Disgust$timebin)

 # create a random arrangment of labels for oroginal and morpj

nsim = 1:1000 #no. of simullation
nbins  =1:40 # numbr of bins. aways check
seed(444)
#create an empty dataframe to store results of the simulation
# remeber to always define it before simulation

simulated_clusters_JEFFE_Disgust<- data.frame(timebins= rep(NA, max(nsim)*max(nbins)), Estimate= rep(NA, max(nsim)*max(nbins)), t=rep(NA, max(nsim)*max(nbins)), p=rep(NA, max(nsim)*max(nbins)), cov= as.character(rep(NA,max(nsim)*max(nbins))), sim = rep(NA, max(nsim)*max(nbins)) )

View(simulated_clusters_JEFFE_Disgust)

# timebin_random_ADFES<- unique(db_of7_new_JEFFE_avg_Disgust$timebin)

# create random labels

i = 1 # remember to always rezero it
# b = 34

seed = 444

simulated_clusters_JEFFE_Disgust$cov<- as.character( simulated_clusters_JEFFE_Disgust$cov) # remeber to run

 i = 1
 # b = 1
 # s = 1
 
 View(db_of7_new_JEFFE_avg_Disgust)
 
 db_of7_new_JEFFE_avg_Disgust$VideoType_contrast<- if_else(db_of7_new_JEFFE_avg_Disgust$morph == "Morph", -.5, .5) # morph == -.5, original .5

 i = 1

for (b in 1:length(nbins)) {
  for (s in 1:length(nsim)) {

    message(sprintf("$$$$$RUNING simulation %i & bin %i", nsim[s], nbins[b]))
    db_of7_new_JEFFE_avg_Disgust$VideoType_contrast_sample<- sample((rep(c(-.5, .5), each =  320)), replace = FALSE) 
        #run the model on the current time bin and simulation sumber
        lmer_bin_random_JEFFE_Disgust  <- lmer(log1p(face_action_AVG +.1) ~ VideoType_contrast_sample + 
                                   (1 |face_unique),
                      data = subset(db_of7_new_JEFFE_avg_Disgust, db_of7_new_JEFFE_avg_Disgust$timebin == timebin_shuff_JEFFE_Disgust[b]))

        #store results from the somularion
            lmer_bin_random_summary_JEFFE_Disgust<- summary(lmer_bin_random_JEFFE_Disgust)
            simulated_clusters_JEFFE_Disgust[i,1]<- timebin_shuff_Disgust[b] #save the exact value of time bin
            simulated_clusters_JEFFE_Disgust[i,2]<- lmer_bin_random_summary_Disgust[["coefficients"]][2,1] # s
            simulated_clusters_JEFFE_Disgust[i,3]<-lmer_bin_random_summary_Disgust[["coefficients"]][2,4] # t statistic
            simulated_clusters_JEFFE_Disgust[i,4]<-lmer_bin_random_summary_Disgust[["coefficients"]][2,5] # p value
           simulated_clusters_JEFFE_Disgust[i,6]<- nsim[s] #store simulation ount
            simulated_clusters_JEFFE_Disgust[i,5]<-ifelse(length(lmer_bin_random_summary_Disgust$optinfo$conv$lme4$message)
                                                   != 0,
                                               lmer_bin_random_summary_Disgust$optinfo$conv$lme4$message, 'pass')

     i = i+1
  }
}
```
Surprise

```{r}
# db_of7_new$Emotion
db_of7_new_JEFFE_avg_Surprise<- subset(db_of7_new, db_of7_new$Dataset == "JEFFE" & db_of7_new$Emotion == "Surprise")



test.data_by_JEFFE_avg_Surprise<- data.frame(timebins= rep(NA, 40), Estimate= rep(NA, 40), t=rep(NA, 40), p=rep(NA, 40), cov= as.character(rep(NA,40)) )

timebin_JEFFE_avg_Surprise<- unique(db_of7_new_JEFFE_avg_Surprise$timebin)
# test.data$timebinout<- as.vector(timebinout) # add the curerent timebins to that vector

# empty list of test results
testresults_JEFFE_avg_Surprise<- list()
# lmer


# currently we have 15 time bins
# the loop below does
# 1 - goes from element i ina  list of eleements 1 to the last time bind_cols
# 2- runs a lmer model regresing face distance to morph vs original, while controling for intercepts of dataset and intercept of unique faces
#3 - stores the result of the model
#4- store informatio on the bin tested, the coeficients, p values and t tests
# morph variance is almost zerp
# dtaset is highly correleted, so ignore


i = 2
for (i in 1:length(timebin_JEFFE_avg_Surprise)) {
  # Surprise_results<- t.test(log1p(D1+.1) ~ morph,var.equal = FALSE, paired = FALSE, data = db_of7_new[db_of7_new$timestamp == timebinout[i],])
  JEFFE_avg_Surprise_results<- lmer(log1p(D1+.1) ~ morph + (1 |face_unique),
                      data = db_of7_new_JEFFE_avg_Surprise[db_of7_new_JEFFE_avg_Surprise$timebin == timebin_JEFFE_avg_Surprise[i],])

  # testresults<- lmer(log1p(D1+.1) ~ morph + (1|face_unique),
  #                     data = db_of7_new [db_of7_new$timebin == timebinout[i] & db_of7_new$Dataset !="ADFES",])
  JEFFE_avg_Surprise_results_sum<- summary(JEFFE_avg_Surprise_results)

   test.data_by_JEFFE_avg_Surprise[i,1]<-timebin_JEFFE_avg_Surprise[i]
   test.data_by_JEFFE_avg_Surprise[i,2]<- JEFFE_avg_Surprise_results_sum[["coefficients"]][2,1]
   test.data_by_JEFFE_avg_Surprise[i,3]<- JEFFE_avg_Surprise_results_sum[["coefficients"]][2,4]
   test.data_by_JEFFE_avg_Surprise[i,4]<- JEFFE_avg_Surprise_results_sum[["coefficients"]][2,5]
  #
   
   
  #     test.data_bySurprise[i,1]<-timestamp_Surprise[i]
  # # test.data_bySurprise[i,2]<- Surprise_results_sum[["coefficients"]][2,1]
  #  test.data_bySurprise[i,3]<- Surprise_results$statistic
  #  test.data_bySurprise[i,4]<- Surprise_results$p.value
  #  # test.data[i,5]<- testresults@optinfo$val
   print(i)
}
summary( JEFFE_avg_Surprise_results)
 # test.data_bySurprise1<- test.data_bySurprise
 test.data_by_JEFFE_avg_Surprise$p_holm<- p.adjust(test.data_by_JEFFE_avg_Surprise$p, length(test.data_by_JEFFE_avg_Surprise$p), method = "holm")
 
 test.data_by_JEFFE_avg_Surprise$p_bonf<- p.adjust(test.data_by_JEFFE_avg_Surprise$p, length(test.data_by_JEFFE_avg_Surprise$p), 
                                          method ="bonf")
  View(test.data_by_JEFFE_avg_Surprise)
# now sum adjancet timebins
  # testresults@optinfo$conv$opt$

plots_of$JEFFE_avg_Surprise <- 
   test.data_by_JEFFE_avg_Surprise%>%
     ggplot(aes(as.numeric(timebins), t))+
     geom_rect(aes(xmin = timebins, xmax = dplyr::lead(timebins), ymin =5.7 , ymax =6 , fill = p_bonf),
            alpha = 0.8)+
     geom_rect(aes(xmin = timebins, xmax = dplyr::lead(timebins), ymin =5.3 , ymax =5.6 , fill = p_holm), 
            alpha = 0.8)+
   geom_rect(aes(xmin = timebins, xmax = dplyr::lead(timebins), ymin =5 , ymax =5.2 , fill = p), 
            alpha = 0.8)+
     geom_hline(yintercept = 2, linetype = 'dashed', size = 1.5, colour = 'red')+
     stat_summary(geom = 'line', size = 2)+
               theme_classic()+
  geom_hline(yintercept = -2, linetype = 'dashed', size = 1.5, colour = 'red')+
     stat_summary(geom = 'line', size = 2)+
               theme_classic()+
     # ylim(1,6)+
      scale_fill_viridis_c()+
     scale_colour_gradient2(mid = "white", limits = c(0,1), midpoint = .5)+
  ggtitle("JEFFE AVG face motion ~ Morph - Surprise")
   
plots_of$JEFFE_avg_Surprise




```


View(test.data_by_JEFFE_avg_Sadness)
```{r}
test.data_by_JEFFE_avg_Surprise <- test.data_by_JEFFE_avg_Surprise %>%
  ungroup()%>%
  mutate(cluster_log = if_else(test.data_by_JEFFE_avg_Surprise$p< .05, TRUE, FALSE))%>%
  mutate(Direction = if_else(t > 0 & cluster_log == TRUE, "Positive", 
                             if_else(t < 0 & cluster_log == TRUE, "Negative", NULL)))%>% # flag direction that is
        # group_by(sim)%>%
        mutate(idx = !is.na(Direction))%>%
        mutate(cluster_counter  = as.numeric(replace(Direction, idx, rleid(rleid(Direction)[idx]))))%>%
      # create a cluster t sum by adjacency, remeber the up there we grouped 
      # cluster counter shuffle makes sure ajancent significant bisn are griuped together
      # direction - do we need thisDirection, cluster_shuffle_log 
      group_by(cluster_counter)%>%
      mutate(t_sum_dir = sum(t))%>%
      # ungroup()%>%
      mutate(t_sum_dir = if_else(cluster_log == TRUE, t_sum_dir, NULL))%>% #summ timebins into clusters statistics
        # create max cluster lavels, store the direction value of the cluster and the label of the direction
      # suppressWarnings
        # group_by(sim)%>%
      mutate(MaxCLust_label = if_else(abs(t_sum_dir) == max(abs(t_sum_dir), na.rm = TRUE),
                                      cluster_counter, NULL ))%>%
      # suppressWarnings
      mutate(MaxCLust_value = if_else(abs(t_sum_dir) == max(abs(t_sum_dir), na.rm = TRUE), 
                                      t_sum_dir, NULL ))%>%
      # suppressWarnings
      mutate(MaxCLust_direction = if_else(MaxCLust_value > 0, "Positive", "Negative"))
View(test.data_by_JEFFE_avg_Surprise)
# negative estmate = morph has less actiation
        
library(data.table)
# create a counter for helpting with cluster by adjancecy

# regular corrections
# test.data_by_JEFFE_avg_Surprise<- test.data_by_JEFFE_avg_Surprise%>%
#   mutate(p_bonf = p.adjust(p, method = 'holm'))%>%
#   mutate(p_holm = p.adjust(p, method = "bonf"))


# go back to the data use to fit - db_of7_new[db_of7_new$timestamp == timebinout_avg[i],])
nrow(db_of7_new_avg_JEFFE_Surprise)
db_of7_new_JEFFE_avg_Surprise%>%
  # filter( Emotion == "Surprise")%>%
  group_by(morph)%>%
  summarise(n = n())# 1280/2



i = 1

View(testtemp)

db_of7_new_JEFFE_avg_Surprise%>%
  # filter(Emotion == "Surprise")%>%
  group_by(video, morph)%>%
  summarise(time = mean(timebin, na.rm = TRUE))%>%
  group_by(morph)%>%
  summarise(n = n()) # collapsing time now we have 16 vidoe per videotype
              
timebin_shuff_JEFFE_Surprise<- unique(db_of7_new_JEFFE_avg_Surprise$timebin)

 # create a random arrangment of labels for oroginal and morpj

nsim = 1:1000 #no. of simullation
nbins  =1:40 # numbr of bins. aways check
seed(444)
#create an empty dataframe to store results of the simulation
# remeber to always define it before simulation

simulated_clusters_JEFFE_Surprise<- data.frame(timebins= rep(NA, max(nsim)*max(nbins)), Estimate= rep(NA, max(nsim)*max(nbins)), t=rep(NA, max(nsim)*max(nbins)), p=rep(NA, max(nsim)*max(nbins)), cov= as.character(rep(NA,max(nsim)*max(nbins))), sim = rep(NA, max(nsim)*max(nbins)) )

View(simulated_clusters_JEFFE_Surprise)

# timebin_random_ADFES<- unique(db_of7_new_JEFFE_avg_Surprise$timebin)

# create random labels

i = 1 # remember to always rezero it
# b = 34

seed = 444

simulated_clusters_JEFFE_Surprise$cov<- as.character( simulated_clusters_JEFFE_Surprise$cov) # remeber to run

 i = 1
 # b = 1
 # s = 1
 
 View(db_of7_new_JEFFE_avg_Surprise)
 
 db_of7_new_JEFFE_avg_Surprise$VideoType_contrast<- if_else(db_of7_new_JEFFE_avg_Surprise$morph == "Morph", -.5, .5) # morph == -.5, original .5

 i = 1

for (b in 1:length(nbins)) {
  for (s in 1:length(nsim)) {

    message(sprintf("$$$$$RUNING simulation %i & bin %i", nsim[s], nbins[b]))
    db_of7_new_JEFFE_avg_Surprise$VideoType_contrast_sample<- sample((rep(c(-.5, .5), each =  320)), replace = FALSE) 
        #run the model on the current time bin and simulation sumber
        lmer_bin_random_JEFFE_Surprise  <- lmer(log1p(face_action_AVG +.1) ~ VideoType_contrast_sample + 
                                   (1 |face_unique),
                      data = subset(db_of7_new_JEFFE_avg_Surprise, db_of7_new_JEFFE_avg_Surprise$timebin == timebin_shuff_JEFFE_Surprise[b]))

        #store results from the somularion
            lmer_bin_random_summary_JEFFE_Surprise<- summary(lmer_bin_random_JEFFE_Surprise)
            simulated_clusters_JEFFE_Surprise[i,1]<- timebin_shuff_Surprise[b] #save the exact value of time bin
            simulated_clusters_JEFFE_Surprise[i,2]<- lmer_bin_random_summary_Surprise[["coefficients"]][2,1] # s
            simulated_clusters_JEFFE_Surprise[i,3]<-lmer_bin_random_summary_Surprise[["coefficients"]][2,4] # t statistic
            simulated_clusters_JEFFE_Surprise[i,4]<-lmer_bin_random_summary_Surprise[["coefficients"]][2,5] # p value
           simulated_clusters_JEFFE_Surprise[i,6]<- nsim[s] #store simulation ount
            simulated_clusters_JEFFE_Surprise[i,5]<-ifelse(length(lmer_bin_random_summary_Surprise$optinfo$conv$lme4$message)
                                                   != 0,
                                               lmer_bin_random_summary_Surprise$optinfo$conv$lme4$message, 'pass')

     i = i+1
  }
}

```

ADFES emotion
Anger


```{r}
# db_of7_new$Emotion
db_of7_new_ADFES_avg_Anger<- subset(db_of7_new, db_of7_new$Dataset == "ADFES" & db_of7_new$Emotion == "Anger")



test.data_by_ADFES_avg_Anger<- data.frame(timebins= rep(NA, 40), Estimate= rep(NA, 40), t=rep(NA, 40), p=rep(NA, 40), cov= as.character(rep(NA,40)) )

timebin_ADFES_avg_Anger<- unique(db_of7_new_ADFES_avg_Anger$timebin)
# test.data$timebinout<- as.vector(timebinout) # add the curerent timebins to that vector

# empty list of test results
testresults_ADFES_avg_Anger<- list()
# lmer


# currently we have 15 time bins
# the loop below does
# 1 - goes from element i ina  list of eleements 1 to the last time bind_cols
# 2- runs a lmer model regresing face distance to morph vs original, while controling for intercepts of dataset and intercept of unique faces
#3 - stores the result of the model
#4- store informatio on the bin tested, the coeficients, p values and t tests
# morph variance is almost zerp
# dtaset is highly correleted, so ignore


i = 2
for (i in 1:length(timebin_ADFES_avg_Anger)) {
  # Surprise_results<- t.test(log1p(D1+.1) ~ morph,var.equal = FALSE, paired = FALSE, data = db_of7_new[db_of7_new$timestamp == timebinout[i],])
  ADFES_avg_Anger_results<- lmer(log1p(D1+.1) ~ morph + (1 |face_unique),
                      data = db_of7_new_ADFES_avg_Anger[db_of7_new_ADFES_avg_Anger$timebin == timebin_ADFES_avg_Anger[i],])

  # testresults<- lmer(log1p(D1+.1) ~ morph + (1|face_unique),
  #                     data = db_of7_new [db_of7_new$timebin == timebinout[i] & db_of7_new$Dataset !="ADFES",])
  ADFES_avg_Anger_results_sum<- summary(ADFES_avg_Anger_results)

   test.data_by_ADFES_avg_Anger[i,1]<-timestamp_ADFES_avg_Anger[i]
   test.data_by_ADFES_avg_Anger[i,2]<- ADFES_avg_Anger_results_sum[["coefficients"]][2,1]
   test.data_by_ADFES_avg_Anger[i,3]<- ADFES_avg_Anger_results_sum[["coefficients"]][2,4]
   test.data_by_ADFES_avg_Anger[i,4]<- ADFES_avg_Anger_results_sum[["coefficients"]][2,5]
  #
   
   
  #     test.data_bySurprise[i,1]<-timestamp_Surprise[i]
  # # test.data_bySurprise[i,2]<- Surprise_results_sum[["coefficients"]][2,1]
  #  test.data_bySurprise[i,3]<- Surprise_results$statistic
  #  test.data_bySurprise[i,4]<- Surprise_results$p.value
  #  # test.data[i,5]<- testresults@optinfo$val
   print(i)
}
summary( ADFES_avg_Anger_results)
 # test.data_bySurprise1<- test.data_bySurprise
 test.data_by_ADFES_avg_Anger$p_holm<- p.adjust(test.data_by_ADFES_avg_Anger$p, length(test.data_by_ADFES_avg_Anger$p), method = "holm")
 
 test.data_by_ADFES_avg_Anger$p_bonf<- p.adjust(test.data_by_ADFES_avg_Anger$p, length(test.data_by_ADFES_avg_Anger$p), 
                                          method ="bonf")
  View(test.data_by_ADFES_avg_Anger)
# now sum adjancet timebins
  # testresults@optinfo$conv$opt$

plots_of$ADFES_avg_Anger <- 
   test.data_by_ADFES_avg_Anger%>%
     ggplot(aes(as.numeric(timebins), t))+
     geom_rect(aes(xmin = timebins, xmax = dplyr::lead(timebins), ymin =5.7 , ymax =6 , fill = p_bonf),
            alpha = 0.8)+
     geom_rect(aes(xmin = timebins, xmax = dplyr::lead(timebins), ymin =5.3 , ymax =5.6 , fill = p_holm), 
            alpha = 0.8)+
   geom_rect(aes(xmin = timebins, xmax = dplyr::lead(timebins), ymin =5 , ymax =5.2 , fill = p), 
            alpha = 0.8)+
     geom_hline(yintercept = 2, linetype = 'dashed', size = 1.5, colour = 'red')+
     stat_summary(geom = 'line', size = 2)+
               theme_classic()+
  geom_hline(yintercept = -2, linetype = 'dashed', size = 1.5, colour = 'red')+
     stat_summary(geom = 'line', size = 2)+
               theme_classic()+
     # ylim(1,6)+
      scale_fill_viridis_c()+
     scale_colour_gradient2(mid = "white", limits = c(0,1), midpoint = .5)+
  ggtitle("ADFES AVG face motion ~ Morph - Anger")
   
plots_of$ADFES_avg_Anger




```

```{r}
View(test.data_by_ADFES_avg_Anger)

test.data_by_ADFES_avg_Anger <- test.data_by_ADFES_avg_Anger %>%
  ungroup()%>%
  mutate(cluster_log = if_else(test.data_by_ADFES_avg_Anger$p< .05, TRUE, FALSE))%>%
  mutate(Direction = if_else(t > 0 & cluster_log == TRUE, "Positive", 
                             if_else(t < 0 & cluster_log == TRUE, "Negative", NULL)))%>% # flag direction that is
        # group_by(sim)%>%
        mutate(idx = !is.na(Direction))%>%
        mutate(cluster_counter  = as.numeric(replace(Direction, idx, rleid(rleid(Direction)[idx]))))%>%
      # create a cluster t sum by adjacency, remeber the up there we grouped 
      # cluster counter shuffle makes sure ajancent significant bisn are griuped together
      # direction - do we need thisDirection, cluster_shuffle_log 
      group_by(cluster_counter)%>%
      mutate(t_sum_dir = sum(t))%>%
      # ungroup()%>%
      mutate(t_sum_dir = if_else(cluster_log == TRUE, t_sum_dir, NULL))%>% #summ timebins into clusters statistics
        # create max cluster lavels, store the direction value of the cluster and the label of the direction
      # suppressWarnings
        # group_by(sim)%>%
      mutate(MaxCLust_label = if_else(abs(t_sum_dir) == max(abs(t_sum_dir), na.rm = TRUE),
                                      cluster_counter, NULL ))%>%
      # suppressWarnings
      mutate(MaxCLust_value = if_else(abs(t_sum_dir) == max(abs(t_sum_dir), na.rm = TRUE), 
                                      t_sum_dir, NULL ))%>%
      # suppressWarnings
      mutate(MaxCLust_direction = if_else(MaxCLust_value > 0, "Positive", "Negative"))
View(test.data_by_ADFES_avg_Anger)
# negative estmate = morph has less actiation
        
library(data.table)
# create a counter for helpting with cluster by adjancecy

# regular corrections
# test.data_by_ADFES_avg_Anger<- test.data_by_ADFES_avg_Anger%>%
#   mutate(p_bonf = p.adjust(p, method = 'holm'))%>%
#   mutate(p_holm = p.adjust(p, method = "bonf"))


# go back to the data use to fit - db_of7_new[db_of7_new$timestamp == timebinout_avg[i],])
nrow(db_of7_new_avg_ADFES_Anger)
db_of7_new_ADFES_avg_Anger%>%
  # filter( Emotion == "Anger")%>%
  group_by(morph)%>%
  summarise(n = n())# 1280/2



i = 1

View(testtemp)

db_of7_new_ADFES_avg_Anger%>%
  # filter(Emotion == "Anger")%>%
  group_by(video, morph)%>%
  summarise(time = mean(timebin, na.rm = TRUE))%>%
  group_by(morph)%>%
  summarise(n = n()) # collapsing time now we have 16 vidoe per videotype
              
timebin_shuff_ADFES_Anger<- unique(db_of7_new_ADFES_avg_Anger$timebin)

 # create a random arrangment of labels for oroginal and morpj

nsim = 1:1000 #no. of simullation
nbins  =1:40 # numbr of bins. aways check

#create an empty dataframe to store results of the simulation
# remeber to always define it before simulation

simulated_clusters_ADFES_Anger<- data.frame(timebins= rep(NA, max(nsim)*max(nbins)), Estimate= rep(NA, max(nsim)*max(nbins)), t=rep(NA, max(nsim)*max(nbins)), p=rep(NA, max(nsim)*max(nbins)), cov= as.character(rep(NA,max(nsim)*max(nbins))), sim = rep(NA, max(nsim)*max(nbins)) )

View(simulated_clusters_Anger)

# timebin_random_ADFES<- unique(db_of7_new_ADFES_avg_Anger$timebin)

# create random labels

i = 1 # remember to always rezero it
# b = 34

seed = 444

simulated_clusters_ADFES_Anger$cov<- as.character( simulated_clusters_ADFES_Anger$cov) # remeber to run

 i = 1
 # b = 1
 # s = 1
 
 View(db_of7_new_ADFES_avg_Anger)
 
 db_of7_new_ADFES_avg_Anger$VideoType_contrast<- if_else(db_of7_new_ADFES_avg_Anger$morph == "Morph", -.5, .5) # morph == -.5, original .5

 i = 1

for (b in 1:length(nbins)) {
  for (s in 1:length(nsim)) {

    message(sprintf("$$$$$RUNING simulation %i & bin %i", nsim[s], nbins[b]))
    db_of7_new_ADFES_avg_Anger$VideoType_contrast_sample<- sample((rep(c(-.5, .5), each =  320)), replace = FALSE) 
        #run the model on the current time bin and simulation sumber
        lmer_bin_random_ADFES_Anger  <- lmer(log1p(face_action_AVG +.1) ~ VideoType_contrast_sample + 
                                   (1 |face_unique),
                      data = subset(db_of7_new_ADFES_avg_Anger, db_of7_new_ADFES_avg_Anger$timebin == timebin_shuff_ADFES_Anger[b]))

        #store results from the somularion
            lmer_bin_random_summary_ADFES_Anger<- summary(lmer_bin_random_ADFES_Anger)
            simulated_clusters_ADFES_Anger[i,1]<- timebin_shuff_Anger[b] #save the exact value of time bin
            simulated_clusters_ADFES_Anger[i,2]<- lmer_bin_random_summary_Anger[["coefficients"]][2,1] # s
            simulated_clusters_ADFES_Anger[i,3]<-lmer_bin_random_summary_Anger[["coefficients"]][2,4] # t statistic
            simulated_clusters_ADFES_Anger[i,4]<-lmer_bin_random_summary_Anger[["coefficients"]][2,5] # p value
           simulated_clusters_ADFES_Anger[i,6]<- nsim[s] #store simulation ount
            simulated_clusters_ADFES_Anger[i,5]<-ifelse(length(lmer_bin_random_summary_Anger$optinfo$conv$lme4$message)
                                                   != 0,
                                               lmer_bin_random_summary_Anger$optinfo$conv$lme4$message, 'pass')

     i = i+1
  }
}

```





Joy

```{r}
# db_of7_new$Emotion
db_of7_new_ADFES_avg_Joy<- subset(db_of7_new, db_of7_new$Dataset == "ADFES" & db_of7_new$Emotion == "Joy")



test.data_by_ADFES_avg_Joy<- data.frame(timebins= rep(NA, 40), Estimate= rep(NA, 40), t=rep(NA, 40), p=rep(NA, 40), cov= as.character(rep(NA,40)) )

timestamp_ADFES_avg_Joy<- unique(db_of7_new_ADFES_avg_Joy$timebin)
# test.data$timebinout<- as.vector(timebinout) # add the curerent timebins to that vector

# empty list of test results
testresults_ADFES_avg_Joy<- list()
# lmer


# currently we have 15 time bins
# the loop below does
# 1 - goes from element i ina  list of eleements 1 to the last time bind_cols
# 2- runs a lmer model regresing face distance to morph vs original, while controling for intercepts of dataset and intercept of unique faces
#3 - stores the result of the model
#4- store informatio on the bin tested, the coeficients, p values and t tests
# morph variance is almost zerp
# dtaset is highly correleted, so ignore


i = 2
for (i in 1:length(timestamp_ADFES_avg_Joy)) {
  # Surprise_results<- t.test(log1p(D1+.1) ~ morph,var.equal = FALSE, paired = FALSE, data = db_of7_new[db_of7_new$timestamp == timebinout[i],])
  ADFES_avg_Joy_results<- lmer(log1p(D1+.1) ~ morph + (1 |face_unique),
                      data = db_of7_new_ADFES_avg_Joy[db_of7_new_ADFES_avg_Joy$timebin == timestamp_ADFES_avg_Joy[i],])

  # testresults<- lmer(log1p(D1+.1) ~ morph + (1|face_unique),
  #                     data = db_of7_new [db_of7_new$timebin == timebinout[i] & db_of7_new$Dataset !="ADFES",])
  ADFES_avg_Joy_results_sum<- summary(ADFES_avg_Joy_results)

   test.data_by_ADFES_avg_Joy[i,1]<-timestamp_ADFES_avg_Joy[i]
   test.data_by_ADFES_avg_Joy[i,2]<- ADFES_avg_Joy_results_sum[["coefficients"]][2,1]
   test.data_by_ADFES_avg_Joy[i,3]<- ADFES_avg_Joy_results_sum[["coefficients"]][2,4]
   test.data_by_ADFES_avg_Joy[i,4]<- ADFES_avg_Joy_results_sum[["coefficients"]][2,5]
  #
   
   
  #     test.data_bySurprise[i,1]<-timestamp_Surprise[i]
  # # test.data_bySurprise[i,2]<- Surprise_results_sum[["coefficients"]][2,1]
  #  test.data_bySurprise[i,3]<- Surprise_results$statistic
  #  test.data_bySurprise[i,4]<- Surprise_results$p.value
  #  # test.data[i,5]<- testresults@optinfo$val
   print(i)
}
summary( ADFES_avg_Joy_results)
 # test.data_bySurprise1<- test.data_bySurprise
 test.data_by_ADFES_avg_Joy$p_holm<- p.adjust(test.data_by_ADFES_avg_Joy$p, length(test.data_by_ADFES_avg_Joy$p), method = "holm")
 
 test.data_by_ADFES_avg_Joy$p_bonf<- p.adjust(test.data_by_ADFES_avg_Joy$p, length(test.data_by_ADFES_avg_Joy$p), 
                                          method ="bonf")
  View(test.data_by_ADFES_avg_Joy)
# now sum adjancet timebins
  # testresults@optinfo$conv$opt$

plots_of$ADFES_avg_Joy <- 
   test.data_by_ADFES_avg_Joy%>%
     ggplot(aes(as.numeric(timebins), t))+
     geom_rect(aes(xmin = timebins, xmax = dplyr::lead(timebins), ymin =5.7 , ymax =6 , fill = p_bonf),
            alpha = 0.8)+
     geom_rect(aes(xmin = timebins, xmax = dplyr::lead(timebins), ymin =5.3 , ymax =5.6 , fill = p_holm), 
            alpha = 0.8)+
   geom_rect(aes(xmin = timebins, xmax = dplyr::lead(timebins), ymin =5 , ymax =5.2 , fill = p), 
            alpha = 0.8)+
     geom_hline(yintercept = 2, linetype = 'dashed', size = 1.5, colour = 'red')+
     stat_summary(geom = 'line', size = 2)+
               theme_classic()+
  geom_hline(yintercept = -2, linetype = 'dashed', size = 1.5, colour = 'red')+
     stat_summary(geom = 'line', size = 2)+
               theme_classic()+
     # ylim(1,6)+
      scale_fill_viridis_c()+
     scale_colour_gradient2(mid = "white", limits = c(0,1), midpoint = .5)+
  ggtitle("ADFES AVG face motion ~ Morph - Joy")
   
plots_of$ADFES_avg_Joy





```
Sadness
```{r}
# db_of7_new$Emotion
db_of7_new_ADFES_avg_Sadness<- subset(db_of7_new, db_of7_new$Dataset == "ADFES" & db_of7_new$Emotion == "Sadness")



test.data_by_ADFES_avg_Sadness<- data.frame(timebins= rep(NA, 40), Estimate= rep(NA, 40), t=rep(NA, 40), p=rep(NA, 40), cov= as.character(rep(NA,40)) )

timestamp_ADFES_avg_Sadness<- unique(db_of7_new_ADFES_avg_Sadness$timebin)
# test.data$timebinout<- as.vector(timebinout) # add the curerent timebins to that vector

# empty list of test results
testresults_ADFES_avg_Sadness<- list()
# lmer


# currently we have 15 time bins
# the loop below does
# 1 - goes from element i ina  list of eleements 1 to the last time bind_cols
# 2- runs a lmer model regresing face distance to morph vs original, while controling for intercepts of dataset and intercept of unique faces
#3 - stores the result of the model
#4- store informatio on the bin tested, the coeficients, p values and t tests
# morph variance is almost zerp
# dtaset is highly correleted, so ignore


i = 2
for (i in 1:length(timestamp_ADFES_avg_Sadness)) {
  # Surprise_results<- t.test(log1p(D1+.1) ~ morph,var.equal = FALSE, paired = FALSE, data = db_of7_new[db_of7_new$timestamp == timebinout[i],])
  ADFES_avg_Sadness_results<- lmer(log1p(D1+.1) ~ morph + (1 |face_unique),
                      data = db_of7_new_ADFES_avg_Sadness[db_of7_new_ADFES_avg_Sadness$timebin == timestamp_ADFES_avg_Sadness[i],])

  # testresults<- lmer(log1p(D1+.1) ~ morph + (1|face_unique),
  #                     data = db_of7_new [db_of7_new$timebin == timebinout[i] & db_of7_new$Dataset !="ADFES",])
  ADFES_avg_Sadness_results_sum<- summary(ADFES_avg_Sadness_results)

   test.data_by_ADFES_avg_Sadness[i,1]<-timestamp_ADFES_avg_Sadness[i]
   test.data_by_ADFES_avg_Sadness[i,2]<- ADFES_avg_Sadness_results_sum[["coefficients"]][2,1]
   test.data_by_ADFES_avg_Sadness[i,3]<- ADFES_avg_Sadness_results_sum[["coefficients"]][2,4]
   test.data_by_ADFES_avg_Sadness[i,4]<- ADFES_avg_Sadness_results_sum[["coefficients"]][2,5]
  #
   
   
  #     test.data_bySurprise[i,1]<-timestamp_Surprise[i]
  # # test.data_bySurprise[i,2]<- Surprise_results_sum[["coefficients"]][2,1]
  #  test.data_bySurprise[i,3]<- Surprise_results$statistic
  #  test.data_bySurprise[i,4]<- Surprise_results$p.value
  #  # test.data[i,5]<- testresults@optinfo$val
   print(i)
}
summary( ADFES_avg_Sadness_results)
 # test.data_bySurprise1<- test.data_bySurprise
 test.data_by_ADFES_avg_Sadness$p_holm<- p.adjust(test.data_by_ADFES_avg_Sadness$p, length(test.data_by_ADFES_avg_Sadness$p), method = "holm")
 
 test.data_by_ADFES_avg_Sadness$p_bonf<- p.adjust(test.data_by_ADFES_avg_Sadness$p, length(test.data_by_ADFES_avg_Sadness$p), 
                                          method ="bonf")
  View(test.data_by_ADFES_avg_Sadness)
# now sum adjancet timebins
  # testresults@optinfo$conv$opt$

plots_of$ADFES_avg_Sadness <- 
   test.data_by_ADFES_avg_Sadness%>%
     ggplot(aes(as.numeric(timebins), t))+
     geom_rect(aes(xmin = timebins, xmax = dplyr::lead(timebins), ymin =5.7 , ymax =6 , fill = p_bonf),
            alpha = 0.8)+
     geom_rect(aes(xmin = timebins, xmax = dplyr::lead(timebins), ymin =5.3 , ymax =5.6 , fill = p_holm), 
            alpha = 0.8)+
   geom_rect(aes(xmin = timebins, xmax = dplyr::lead(timebins), ymin =5 , ymax =5.2 , fill = p), 
            alpha = 0.8)+
     geom_hline(yintercept = 2, linetype = 'dashed', size = 1.5, colour = 'red')+
     stat_summary(geom = 'line', size = 2)+
               theme_classic()+
  geom_hline(yintercept = -2, linetype = 'dashed', size = 1.5, colour = 'red')+
     stat_summary(geom = 'line', size = 2)+
               theme_classic()+
     # ylim(1,6)+
      scale_fill_viridis_c()+
     scale_colour_gradient2(mid = "white", limits = c(0,1), midpoint = .5)+
  ggtitle("ADFES AVG face motion ~ Morph - Sadness")
   
plots_of$ADFES_avg_Sadness



```


Fear

```{r}
# db_of7_new$Emotion
db_of7_new_ADFES_avg_Fear<- subset(db_of7_new, db_of7_new$Dataset == "ADFES" & db_of7_new$Emotion == "Fear")



test.data_by_ADFES_avg_Fear<- data.frame(timebins= rep(NA, 40), Estimate= rep(NA, 40), t=rep(NA, 40), p=rep(NA, 40), cov= as.character(rep(NA,40)) )

timestamp_ADFES_avg_Fear<- unique(db_of7_new_ADFES_avg_Fear$timebin)
# test.data$timebinout<- as.vector(timebinout) # add the curerent timebins to that vector

# empty list of test results
testresults_ADFES_avg_Fear<- list()
# lmer


# currently we have 15 time bins
# the loop below does
# 1 - goes from element i ina  list of eleements 1 to the last time bind_cols
# 2- runs a lmer model regresing face distance to morph vs original, while controling for intercepts of dataset and intercept of unique faces
#3 - stores the result of the model
#4- store informatio on the bin tested, the coeficients, p values and t tests
# morph variance is almost zerp
# dtaset is highly correleted, so ignore


i = 2
for (i in 1:length(timestamp_ADFES_avg_Fear)) {
  # Surprise_results<- t.test(log1p(D1+.1) ~ morph,var.equal = FALSE, paired = FALSE, data = db_of7_new[db_of7_new$timestamp == timebinout[i],])
  ADFES_avg_Fear_results<- lmer(log1p(D1+.1) ~ morph + (1 |face_unique),
                      data = db_of7_new_ADFES_avg_Fear[db_of7_new_ADFES_avg_Fear$timebin == timestamp_ADFES_avg_Fear[i],])

  # testresults<- lmer(log1p(D1+.1) ~ morph + (1|face_unique),
  #                     data = db_of7_new [db_of7_new$timebin == timebinout[i] & db_of7_new$Dataset !="ADFES",])
  ADFES_avg_Fear_results_sum<- summary(ADFES_avg_Fear_results)

   test.data_by_ADFES_avg_Fear[i,1]<-timestamp_ADFES_avg_Fear[i]
   test.data_by_ADFES_avg_Fear[i,2]<- ADFES_avg_Fear_results_sum[["coefficients"]][2,1]
   test.data_by_ADFES_avg_Fear[i,3]<- ADFES_avg_Fear_results_sum[["coefficients"]][2,4]
   test.data_by_ADFES_avg_Fear[i,4]<- ADFES_avg_Fear_results_sum[["coefficients"]][2,5]
  #
   
   
  #     test.data_bySurprise[i,1]<-timestamp_Surprise[i]
  # # test.data_bySurprise[i,2]<- Surprise_results_sum[["coefficients"]][2,1]
  #  test.data_bySurprise[i,3]<- Surprise_results$statistic
  #  test.data_bySurprise[i,4]<- Surprise_results$p.value
  #  # test.data[i,5]<- testresults@optinfo$val
   print(i)
}
summary( ADFES_avg_Fear_results)
 # test.data_bySurprise1<- test.data_bySurprise
 test.data_by_ADFES_avg_Fear$p_holm<- p.adjust(test.data_by_ADFES_avg_Fear$p, length(test.data_by_ADFES_avg_Fear$p), method = "holm")
 
 test.data_by_ADFES_avg_Fear$p_bonf<- p.adjust(test.data_by_ADFES_avg_Fear$p, length(test.data_by_ADFES_avg_Fear$p), 
                                          method ="bonf")
  View(test.data_by_ADFES_avg_Fear)
# now sum adjancet timebins
  # testresults@optinfo$conv$opt$

plots_of$ADFES_avg_Fear <- 
   test.data_by_ADFES_avg_Fear%>%
     ggplot(aes(as.numeric(timebins), t))+
     geom_rect(aes(xmin = timebins, xmax = dplyr::lead(timebins), ymin =5.7 , ymax =6 , fill = p_bonf),
            alpha = 0.8)+
     geom_rect(aes(xmin = timebins, xmax = dplyr::lead(timebins), ymin =5.3 , ymax =5.6 , fill = p_holm), 
            alpha = 0.8)+
   geom_rect(aes(xmin = timebins, xmax = dplyr::lead(timebins), ymin =5 , ymax =5.2 , fill = p), 
            alpha = 0.8)+
     geom_hline(yintercept = 2, linetype = 'dashed', size = 1.5, colour = 'red')+
     stat_summary(geom = 'line', size = 2)+
               theme_classic()+
  geom_hline(yintercept = -2, linetype = 'dashed', size = 1.5, colour = 'red')+
     stat_summary(geom = 'line', size = 2)+
               theme_classic()+
     # ylim(1,6)+
      scale_fill_viridis_c()+
     scale_colour_gradient2(mid = "white", limits = c(0,1), midpoint = .5)+
  ggtitle("ADFES AVG face motion ~ Morph - Fear")
   
plots_of$ADFES_avg_Fear



```

Disgust
```{r}
# db_of7_new$Emotion
db_of7_new_ADFES_avg_Disgust<- subset(db_of7_new, db_of7_new$Dataset == "ADFES" & db_of7_new$Emotion == "Disgust")



test.data_by_ADFES_avg_Disgust<- data.frame(timebins= rep(NA, 40), Estimate= rep(NA, 40), t=rep(NA, 40), p=rep(NA, 40), cov= as.character(rep(NA,40)) )

timestamp_ADFES_avg_Disgust<- unique(db_of7_new_ADFES_avg_Disgust$timebin)
# test.data$timebinout<- as.vector(timebinout) # add the curerent timebins to that vector

# empty list of test results
testresults_ADFES_avg_Disgust<- list()
# lmer


# currently we have 15 time bins
# the loop below does
# 1 - goes from element i ina  list of eleements 1 to the last time bind_cols
# 2- runs a lmer model regresing face distance to morph vs original, while controling for intercepts of dataset and intercept of unique faces
#3 - stores the result of the model
#4- store informatio on the bin tested, the coeficients, p values and t tests
# morph variance is almost zerp
# dtaset is highly correleted, so ignore


i = 2
for (i in 1:length(timestamp_ADFES_avg_Disgust)) {
  # Surprise_results<- t.test(log1p(D1+.1) ~ morph,var.equal = FALSE, paired = FALSE, data = db_of7_new[db_of7_new$timestamp == timebinout[i],])
  ADFES_avg_Disgust_results<- lmer(log1p(D1+.1) ~ morph + (1 |face_unique),
                      data = db_of7_new_ADFES_avg_Disgust[db_of7_new_ADFES_avg_Disgust$timebin == timestamp_ADFES_avg_Disgust[i],])

  # testresults<- lmer(log1p(D1+.1) ~ morph + (1|face_unique),
  #                     data = db_of7_new [db_of7_new$timebin == timebinout[i] & db_of7_new$Dataset !="ADFES",])
  ADFES_avg_Disgust_results_sum<- summary(ADFES_avg_Disgust_results)

   test.data_by_ADFES_avg_Disgust[i,1]<-timestamp_ADFES_avg_Disgust[i]
   test.data_by_ADFES_avg_Disgust[i,2]<- ADFES_avg_Disgust_results_sum[["coefficients"]][2,1]
   test.data_by_ADFES_avg_Disgust[i,3]<- ADFES_avg_Disgust_results_sum[["coefficients"]][2,4]
   test.data_by_ADFES_avg_Disgust[i,4]<- ADFES_avg_Disgust_results_sum[["coefficients"]][2,5]
  #
   
   
  #     test.data_bySurprise[i,1]<-timestamp_Surprise[i]
  # # test.data_bySurprise[i,2]<- Surprise_results_sum[["coefficients"]][2,1]
  #  test.data_bySurprise[i,3]<- Surprise_results$statistic
  #  test.data_bySurprise[i,4]<- Surprise_results$p.value
  #  # test.data[i,5]<- testresults@optinfo$val
   print(i)
}
summary( ADFES_avg_Disgust_results)
 # test.data_bySurprise1<- test.data_bySurprise
 test.data_by_ADFES_avg_Disgust$p_holm<- p.adjust(test.data_by_ADFES_avg_Disgust$p, length(test.data_by_ADFES_avg_Disgust$p), method = "holm")
 
 test.data_by_ADFES_avg_Disgust$p_bonf<- p.adjust(test.data_by_ADFES_avg_Disgust$p, length(test.data_by_ADFES_avg_Disgust$p), 
                                          method ="bonf")
  View(test.data_by_ADFES_avg_Disgust)
# now sum adjancet timebins
  # testresults@optinfo$conv$opt$

plots_of$ADFES_avg_Disgust <- 
   test.data_by_ADFES_avg_Disgust%>%
     ggplot(aes(as.numeric(timebins), t))+
     geom_rect(aes(xmin = timebins, xmax = dplyr::lead(timebins), ymin =5.7 , ymax =6 , fill = p_bonf),
            alpha = 0.8)+
     geom_rect(aes(xmin = timebins, xmax = dplyr::lead(timebins), ymin =5.3 , ymax =5.6 , fill = p_holm), 
            alpha = 0.8)+
   geom_rect(aes(xmin = timebins, xmax = dplyr::lead(timebins), ymin =5 , ymax =5.2 , fill = p), 
            alpha = 0.8)+
     geom_hline(yintercept = 2, linetype = 'dashed', size = 1.5, colour = 'red')+
     stat_summary(geom = 'line', size = 2)+
               theme_classic()+
  geom_hline(yintercept = -2, linetype = 'dashed', size = 1.5, colour = 'red')+
     stat_summary(geom = 'line', size = 2)+
               theme_classic()+
     # ylim(1,6)+
      scale_fill_viridis_c()+
     scale_colour_gradient2(mid = "white", limits = c(0,1), midpoint = .5)+
  ggtitle("ADFES AVG face motion ~ Morph - Disgust")
   
plots_of$ADFES_avg_Disgust





```


Surprise

```{r}
# db_of7_new$Emotion
db_of7_new_ADFES_avg_Surprise<- subset(db_of7_new, db_of7_new$Dataset == "ADFES" & db_of7_new$Emotion == "Surprise")



test.data_by_ADFES_avg_Surprise<- data.frame(timebins= rep(NA, 40), Estimate= rep(NA, 40), t=rep(NA, 40), p=rep(NA, 40), cov= as.character(rep(NA,40)) )

timestamp_ADFES_avg_Surprise<- unique(db_of7_new_ADFES_avg_Surprise$timebin)
# test.data$timebinout<- as.vector(timebinout) # add the curerent timebins to that vector

# empty list of test results
testresults_ADFES_avg_Surprise<- list()
# lmer


# currently we have 15 time bins
# the loop below does
# 1 - goes from element i ina  list of eleements 1 to the last time bind_cols
# 2- runs a lmer model regresing face distance to morph vs original, while controling for intercepts of dataset and intercept of unique faces
#3 - stores the result of the model
#4- store informatio on the bin tested, the coeficients, p values and t tests
# morph variance is almost zerp
# dtaset is highly correleted, so ignore


i = 2
for (i in 1:length(timestamp_ADFES_avg_Surprise)) {
  # Surprise_results<- t.test(log1p(D1+.1) ~ morph,var.equal = FALSE, paired = FALSE, data = db_of7_new[db_of7_new$timestamp == timebinout[i],])
  ADFES_avg_Surprise_results<- lmer(log1p(D1+.1) ~ morph + (1 |face_unique),
                      data = db_of7_new_ADFES_avg_Surprise[db_of7_new_ADFES_avg_Surprise$timebin == timestamp_ADFES_avg_Surprise[i],])

  # testresults<- lmer(log1p(D1+.1) ~ morph + (1|face_unique),
  #                     data = db_of7_new [db_of7_new$timebin == timebinout[i] & db_of7_new$Dataset !="ADFES",])
  ADFES_avg_Surprise_results_sum<- summary(ADFES_avg_Surprise_results)

   test.data_by_ADFES_avg_Surprise[i,1]<-timestamp_ADFES_avg_Surprise[i]
   test.data_by_ADFES_avg_Surprise[i,2]<- ADFES_avg_Surprise_results_sum[["coefficients"]][2,1]
   test.data_by_ADFES_avg_Surprise[i,3]<- ADFES_avg_Surprise_results_sum[["coefficients"]][2,4]
   test.data_by_ADFES_avg_Surprise[i,4]<- ADFES_avg_Surprise_results_sum[["coefficients"]][2,5]
  #
   
   
  #     test.data_bySurprise[i,1]<-timestamp_Surprise[i]
  # # test.data_bySurprise[i,2]<- Surprise_results_sum[["coefficients"]][2,1]
  #  test.data_bySurprise[i,3]<- Surprise_results$statistic
  #  test.data_bySurprise[i,4]<- Surprise_results$p.value
  #  # test.data[i,5]<- testresults@optinfo$val
   print(i)
}
summary( ADFES_avg_Surprise_results)
 # test.data_bySurprise1<- test.data_bySurprise
 test.data_by_ADFES_avg_Surprise$p_holm<- p.adjust(test.data_by_ADFES_avg_Surprise$p, length(test.data_by_ADFES_avg_Surprise$p), method = "holm")
 
 test.data_by_ADFES_avg_Surprise$p_bonf<- p.adjust(test.data_by_ADFES_avg_Surprise$p, length(test.data_by_ADFES_avg_Surprise$p), 
                                          method ="bonf")
  View(test.data_by_ADFES_avg_Surprise)
# now sum adjancet timebins
  # testresults@optinfo$conv$opt$

plots_of$ADFES_avg_Surprise <- 
   test.data_by_ADFES_avg_Surprise%>%
     ggplot(aes(as.numeric(timebins), t))+
     geom_rect(aes(xmin = timebins, xmax = dplyr::lead(timebins), ymin =5.7 , ymax =6 , fill = p_bonf),
            alpha = 0.8)+
     geom_rect(aes(xmin = timebins, xmax = dplyr::lead(timebins), ymin =5.3 , ymax =5.6 , fill = p_holm), 
            alpha = 0.8)+
   geom_rect(aes(xmin = timebins, xmax = dplyr::lead(timebins), ymin =5 , ymax =5.2 , fill = p), 
            alpha = 0.8)+
     geom_hline(yintercept = 2, linetype = 'dashed', size = 1.5, colour = 'red')+
     stat_summary(geom = 'line', size = 2)+
               theme_classic()+
  geom_hline(yintercept = -2, linetype = 'dashed', size = 1.5, colour = 'red')+
     stat_summary(geom = 'line', size = 2)+
               theme_classic()+
     # ylim(1,6)+
      scale_fill_viridis_c()+
     scale_colour_gradient2(mid = "white", limits = c(0,1), midpoint = .5)+
  ggtitle("ADFES AVG face motion ~ Morph - Surprise")
   
plots_of$ADFES_avg_Surprise




```